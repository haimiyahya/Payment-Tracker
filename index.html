<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Payment Tracker</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.5/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;

    // Initialize Dexie.js for IndexedDB
    const db = new Dexie("PaymentTrackerDB");
    db.version(1).stores({
      students: "++id,name,expectedAmount,paidAmount,transactionDate,status,pdfFilename",
      invalidReceipts: "++id,filename,reason,data",
      settings: "key,value"
    });

    // Simplified BM25 implementation
    const BM25 = {
      k1: 1.5,
      b: 0.75,
      threshold: 0.8,
      tokenize: (text) => text.toLowerCase().split(/\W+/).filter(t => t.length >= 2),
      computeScore: (query, doc, docLength, avgDocLength, idf) => {
        let score = 0;
        query.forEach(term => {
          const freq = doc.filter(t => t === term).length;
          const numerator = freq * (BM25.k1 + 1);
          const denominator = freq + BM25.k1 * (1 - BM25.b + BM25.b * (docLength / avgDocLength));
          score += idf[term] * numerator / denominator;
        });
        return score;
      },
      match: (query, documents) => {
        console.log(`BM25.match: Query=${query}, Documents=${JSON.stringify(documents.map(d => ({ id: d.id, name: d.name })))}`);
        const tokens = BM25.tokenize(query);
        console.log(`BM25.match: Query tokens=${tokens}`);
        const docTokens = documents.map(doc => ({
          id: doc.id,
          name: doc.name,
          tokens: BM25.tokenize(doc.name)
        }));
        console.log(`BM25.match: Doc tokens=${JSON.stringify(docTokens.map(dt => ({ id: dt.id, name: dt.name, tokens: dt.tokens })))}`);
        const docLengths = docTokens.map(dt => dt.tokens.length);
        const avgDocLength = docLengths.reduce((a, b) => a + b, 0) / docLengths.length || 1;
        const idf = {};
        tokens.forEach(term => {
          const docsWithTerm = docTokens.filter(dt => dt.tokens.includes(term)).length;
          idf[term] = Math.log((documents.length - docsWithTerm + 0.5) / (docsWithTerm + 0.5) + 1);
        });
        const scores = docTokens.map(dt => ({
          id: dt.id,
          name: dt.name,
          score: BM25.computeScore(tokens, dt.tokens, dt.tokens.length, avgDocLength, idf)
        }));
        console.log(`BM25.match: Scores=${JSON.stringify(scores)}`);
        const sorted = scores.sort((a, b) => b.score - a.score);
        if (sorted[0] && sorted[0].score > BM25.threshold) {
          const topScore = sorted[0].score;
          const closeScores = sorted.filter(s => s.score >= topScore * 0.9);
          if (closeScores.length === 1) {
            console.log(`BM25.match: Returning match=${JSON.stringify(sorted[0])}`);
            return sorted[0];
          }
        }
        console.log(`BM25.match: No match found`);
        return null;
      }
    };

    // Function to clean and prioritize PDF text
    const formatPDFText = (text) => {
      if (!text || typeof text !== "string") return "No text available";

      // Remove non-printable characters (ASCII < 32, except for space)
      let cleaned = text.replace(/[\x00-\x1F\x7F]+/g, " ");
      // Replace multiple spaces with a single space
      cleaned = cleaned.replace(/\s+/g, " ").trim();

      // Extract key information using regex
      const amountRegex = /\RM?\d+\.\d{2}\b|\d+\s*RM\b/i;
      const dateRegex = /\b(\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\s+\d{2}:\d{2}:\d{2}|\d{1,2}[/-]\d{1,2}[/-]\d{2,4}(?:\s+\d{2}:\d{2}:\d{2})?|\d{4}[/-]\d{1,2}[/-]\d{1,2}(?:\s+\d{2}:\d{2}:\d{2})?)\b/i;
      const refNumberRegex = /\b\d{10}\b/;
      const otherDetailsRegex = /\bYURAN\s+(?:JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\s+\d{4}\b/;

      const amountMatch = cleaned.match(amountRegex);
      const dateMatch = cleaned.match(dateRegex);
      const refNumberMatch = cleaned.match(refNumberRegex);
      const otherDetailsMatch = cleaned.match(otherDetailsRegex);

      // Prioritize key information
      let prioritizedText = "";
      if (dateMatch) {
        prioritizedText += `Date: ${dateMatch[0]}\n`;
      }
      if (amountMatch) {
        prioritizedText += `Amount: ${amountMatch[0]}\n`;
      }
      if (refNumberMatch) {
        prioritizedText += `Reference Number: ${refNumberMatch[0]}\n`;
      }
      if (otherDetailsMatch) {
        prioritizedText += `Other Transfer Details: ${otherDetailsMatch[0]}\n`;
      }

      // Add the rest of the text, excluding already included parts
      let remainingText = cleaned;
      if (amountMatch) remainingText = remainingText.replace(amountMatch[0], "").replace(/\s+/g, " ").trim();
      if (dateMatch) remainingText = remainingText.replace(dateMatch[0], "").replace(/\s+/g, " ").trim();
      if (refNumberMatch) remainingText = remainingText.replace(refNumberMatch[0], "").replace(/\s+/g, " ").trim();
      if (otherDetailsMatch) remainingText = remainingText.replace(otherDetailsMatch[0], "").replace(/\s+/g, " ").trim();

      prioritizedText += remainingText;

      // Truncate to 500 characters for display
      if (prioritizedText.length > 500) {
        prioritizedText = prioritizedText.substring(0, 500) + "...";
      }

      return prioritizedText || "No text available";
    };

    // Main App Component
    function App() {
      const [isAuthenticated, setIsAuthenticated] = useState(false);
      const [password, setPassword] = useState("");
      const [error, setError] = useState(""); // General errors (e.g., login, CSV)
      const [pdfError, setPdfError] = useState(""); // PDF-specific errors
      const [students, setStudents] = useState([]);
      const [invalidReceipts, setInvalidReceipts] = useState([]);
      const [newStudent, setNewStudent] = useState({ name: "", expectedAmount: "" });
      const [filter, setFilter] = useState("All");
      const [sortBy, setSortBy] = useState("name-asc");
      const [sessionTimeout, setSessionTimeout] = useState(null);
      const [isDragging, setIsDragging] = useState(false);
      const [isDraggingCSV, setIsDraggingCSV] = useState(false);

      // Load data from IndexedDB
      const loadData = async () => {
        const studentsData = await db.students.toArray();
        const invalidData = await db.invalidReceipts.toArray();
        setStudents(studentsData.map(s => ({
          ...s,
          status: s.status || (s.paidAmount ? (s.paidAmount === s.expectedAmount ? "Paid" : "Incorrect") : "No File Matched"),
          pdfFilename: s.pdfFilename || null,
          transactionDate: s.transactionDate || null
        })));
        setInvalidReceipts(invalidData);
      };

      // Session management
      useEffect(() => {
        const checkSession = async () => {
          const session = await db.settings.get("session");
          if (session && session.value > Date.now()) {
            setIsAuthenticated(true);
            await loadData(); // Load data on successful session check
            resetSessionTimeout();
          } else {
            setIsAuthenticated(false);
          }
        };
        checkSession();
        return () => clearTimeout(sessionTimeout);
      }, []);

      const resetSessionTimeout = () => {
        clearTimeout(sessionTimeout);
        const timeout = setTimeout(async () => {
          setIsAuthenticated(false);
          await db.settings.delete("session");
          setError("Session timed out. Please log in again.");
          setStudents([]);
          setInvalidReceipts([]);
        }, 30 * 60 * 1000);
        setSessionTimeout(timeout);
      };

      // Handle login
      const handleLogin = async (e) => {
        e.preventDefault();
        setError("");
        const storedKey = await db.settings.get("passwordKey");
        const derivedKey = CryptoJS.PBKDF2(password, "salt", { keySize: 256/32, iterations: 1000 }).toString();
        
        if (!storedKey) {
          await db.settings.put({ key: "passwordKey", value: derivedKey });
          await db.settings.put({ key: "session", value: Date.now() + 30 * 60 * 1000 });
          setIsAuthenticated(true);
          await loadData(); // Load data after successful login
          resetSessionTimeout();
          setPassword("");
        } else if (storedKey.value === derivedKey) {
          await db.settings.put({ key: "session", value: Date.now() + 30 * 60 * 1000 });
          setIsAuthenticated(true);
          await loadData(); // Load data after successful login
          resetSessionTimeout();
          setPassword("");
        } else {
          setError("Incorrect password");
        }
      };

      // Handle logout
      const handleLogout = async () => {
        await db.settings.delete("session");
        clearTimeout(sessionTimeout);
        setIsAuthenticated(false);
        setError("");
        setPdfError("");
        setStudents([]); // Clear students on logout
        setInvalidReceipts([]); // Clear invalid receipts on logout
      };

      // Add single student
      const addStudent = async (e) => {
        e.preventDefault();
        const { name, expectedAmount } = newStudent;
        if (!name.trim() || isNaN(expectedAmount) || expectedAmount <= 0) {
          setError("Invalid name or amount");
          return;
        }
        const student = {
          name: name.trim(),
          expectedAmount: parseFloat(expectedAmount).toFixed(2),
          paidAmount: null,
          transactionDate: null,
          status: "No File Matched",
          pdfFilename: null
        };
        const id = await db.students.add(student);
        setStudents(prev => [...prev, { ...student, id }]);
        setNewStudent({ name: "", expectedAmount: "" });
      };

      // Process CSV file for bulk student upload
      const processCSV = async (file) => {
        console.log(`Processing CSV: ${file.name}`);
        try {
          const text = await file.text();
          Papa.parse(text, {
            header: true,
            skipEmptyLines: true,
            complete: async (result) => {
              const data = result.data;
              const errors = [];
              const validStudents = [];

              // Normalize headers: strip quotes, whitespace, BOM, and make case-insensitive
              const headers = result.meta.fields.map(h => 
                h.replace(/[\uFEFF"']+/g, '').trim().toLowerCase()
              );
              console.log(`Parsed headers: ${JSON.stringify(headers)}`);

              // Expected headers (case-insensitive)
              const requiredHeaders = ["name", "expected amount"];
              const nameHeader = headers.find(h => h === "name");
              const amountHeader = headers.find(h => h === "expected amount");

              if (!nameHeader || !amountHeader) {
                setError("CSV must have 'Name' and 'Expected Amount' columns (case-insensitive)");
                return;
              }

              // Find original header names for accessing data
              const originalNameHeader = result.meta.fields[headers.indexOf("name")];
              const originalAmountHeader = result.meta.fields[headers.indexOf("expected amount")];

              // Process each row
              for (let i = 0; i < data.length; i++) {
                const row = data[i];
                const name = row[originalNameHeader]?.trim();
                const expectedAmount = parseFloat(row[originalAmountHeader]);

                if (!name || isNaN(expectedAmount) || expectedAmount <= 0) {
                  errors.push(`Row ${i + 2}: Invalid name or amount`);
                  continue;
                }

                validStudents.push({
                  name,
                  expectedAmount: expectedAmount.toFixed(2),
                  paidAmount: null,
                  transactionDate: null,
                  status: "No File Matched",
                  pdfFilename: null
                });
              }

              // Add valid students to database
              if (validStudents.length > 0) {
                const ids = await db.students.bulkAdd(validStudents, { allKeys: true });
                const newStudents = validStudents.map((student, index) => ({
                  ...student,
                  id: ids[index]
                }));
                setStudents(prev => [...prev, ...newStudents]);
                console.log(`Added ${newStudents.length} students from CSV`);
              }

              // Report errors
              if (errors.length > 0) {
                setError(`Added ${validStudents.length} students. Errors: ${errors.join("; ")}`);
              } else {
                setError(`Successfully added ${validStudents.length} students`);
              }
            },
            error: (err) => {
              console.error(`Error parsing CSV ${file.name}:`, err);
              setError(`Failed to parse CSV: ${err.message}`);
            }
          });
        } catch (err) {
          console.error(`Error processing CSV ${file.name}:`, err);
          setError(`Failed to process CSV: ${err.message}`);
        }
      };

      // Handle CSV file upload
      const handleCSVUpload = async (files) => {
        const csvFiles = Array.from(files).filter(f => f.type === "text/csv" || f.name.endsWith(".csv"));
        if (csvFiles.length === 0) {
          setError("Please upload a valid CSV file");
          return;
        }
        setError("");
        for (const file of csvFiles) {
          await processCSV(file);
        }
      };

      // CSV drag-and-drop handlers
      const handleCSVDragOver = (e) => {
        e.preventDefault();
        setIsDraggingCSV(true);
      };

      const handleCSVDragLeave = (e) => {
        e.preventDefault();
        setIsDraggingCSV(false);
      };

      const handleCSVDrop = (e) => {
        e.preventDefault();
        setIsDraggingCSV(false);
        const files = e.dataTransfer.files;
        handleCSVUpload(files);
      };

      // Edit student
      const editStudent = async (id, updatedStudent) => {
        if (!updatedStudent.name.trim() || isNaN(updatedStudent.expectedAmount) || updatedStudent.expectedAmount <= 0) {
          setError("Invalid name or amount");
          return;
        }
        updatedStudent.expectedAmount = parseFloat(updatedStudent.expectedAmount).toFixed(2);
        await db.students.update(id, updatedStudent);
        setStudents(prev => prev.map(s => (s.id === id ? { ...s, ...updatedStudent } : s)));
      };

      // Delete student
      const deleteStudent = async (id) => {
        await db.students.delete(id);
        setStudents(prev => prev.filter(s => s.id !== id));
      };

      // Validate PDF file by checking magic number
      const validatePDFFile = async (file) => {
        try {
          const arrayBuffer = await file.slice(0, 5).arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);
          const magicNumber = String.fromCharCode(...uint8Array);
          return magicNumber === "%PDF-";
        } catch (err) {
          console.error(`Error validating PDF ${file.name}:`, err);
          return false;
        }
      };

      // Process PDF
      const processPDF = async (file) => {
        console.log(`Processing PDF: ${file.name}`);
        let text = "";
        try {
          // Validate PDF magic number
          const isValidPDF = await validatePDFFile(file);
          if (!isValidPDF) {
            throw new Error("Invalid PDF format: File does not start with %PDF-");
          }

          const arrayBuffer = await file.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
          for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const content = await page.getTextContent();
            text += content.items.map(item => item.str).join(" ") + " ";
          }
          console.log(`Extracted text from ${file.name}: ${text.slice(0, 100)}...`);

          const nameRegex = students.map(s => new RegExp(`\\b${s.name}\\b`, "i"));
          const amountRegex = /\RM?\d+\.\d{2}\b|\d+\s*RM\b/i;
          const dateRegex = /\b(\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\s+\d{2}:\d{2}:\d{2}|\d{1,2}[/-]\d{1,2}[/-]\d{2,4}(?:\s+\d{2}:\d{2}:\d{2})?|\d{4}[/-]\d{1,2}[/-]\d{1,2}(?:\s+\d{2}:\d{2}:\d{2})?)\b/i;
          const extractedText = text.toLowerCase();
          let matchedName = null;
          for (const regex of nameRegex) {
            const match = text.match(regex);
            if (match) {
              matchedName = students.find(s => regex.test(s.name))?.name;
              break;
            }
          }
          const amountMatch = text.match(amountRegex);
          const extractedAmount = amountMatch ? parseFloat(amountMatch[0].replace(/[^\d.]/g, "")) : null;
          let transactionDate = null;
          const dateMatch = text.match(dateRegex);
          if (dateMatch) {
            transactionDate = dateMatch[0];
            console.log(`Extracted transaction date from ${file.name}: ${transactionDate}`);
          }
          console.log(`Extracted from ${file.name}: Name=${matchedName}, Amount=${extractedAmount}, Date=${transactionDate}`);

          let matchedStudent = null;
          if (matchedName) {
            matchedStudent = students.find(s => s.name.toLowerCase() === matchedName.toLowerCase());
            console.log(`Matched by name: ${matchedStudent ? matchedStudent.name : 'None'}`);
          } else {
            const filename = file.name.replace(".pdf", "");
            matchedStudent = BM25.match(filename, students);
            console.log(`BM25 match for ${filename}: ${matchedStudent ? matchedStudent.name : 'None'}`);
          }

          if (!matchedStudent || !extractedAmount) {
            let reason = "No student matched";
            if (matchedStudent && !extractedAmount) {
              reason = "No amount found in PDF";
            }
            // Check for duplicate receipt
            const existingReceipt = await db.invalidReceipts.where("filename").equals(file.name).first();
            if (existingReceipt) {
              console.log(`Duplicate receipt detected: ${file.name}`);
              setPdfError(`Duplicate receipt detected: ${file.name}. Skipping.`);
              return;
            }
            console.log(`Invalid receipt: ${file.name}, Reason: ${reason}`);
            const id = await db.invalidReceipts.add({ filename: file.name, reason, data: text || "Unable to extract text" });
            setInvalidReceipts(prev => [...prev, { id, filename: file.name, reason, data: text || "Unable to extract text" }]);
            setPdfError(`Failed to process ${file.name}: ${reason}. You can manually assign this receipt below.`);
            return;
          }

          const status = extractedAmount.toFixed(2) === matchedStudent.expectedAmount ? "Paid" : "Incorrect";
          console.log(`Updating student ${matchedStudent.name}: Status=${status}, Amount=${extractedAmount}, Date=${transactionDate}, PDF=${file.name}`);
          await db.students.update(matchedStudent.id, { 
            paidAmount: extractedAmount.toFixed(2), 
            transactionDate: transactionDate,
            status, 
            pdfFilename: file.name 
          });
          setStudents(prev => prev.map(s => 
            s.id === matchedStudent.id ? { ...s, paidAmount: extractedAmount.toFixed(2), transactionDate: transactionDate, status, pdfFilename: file.name } : s
          ));
        } catch (err) {
          console.error(`Error processing ${file.name}:`, err);
          let userFriendlyMessage = "The file may be corrupted or not a valid PDF. Please upload a different file.";
          if (err.message.includes("Invalid PDF format")) {
            userFriendlyMessage = "The file is not a valid PDF. Please upload a different file.";
          } else if (err.message.includes("doc is not defined")) {
            userFriendlyMessage = "The file could not be read as a PDF. It may be corrupted or in an unsupported format.";
          } else if (err.message.includes("Invalid PDF structure")) {
            userFriendlyMessage = "The PDF structure is invalid. Please upload a different file.";
          }
          
          const reason = `Failed to process: ${userFriendlyMessage}`;
          // Check for duplicate receipt
          const existingReceipt = await db.invalidReceipts.where("filename").equals(file.name).first();
          if (existingReceipt) {
            console.log(`Duplicate receipt detected: ${file.name}`);
            setPdfError(`Duplicate receipt detected: ${file.name}. Skipping.`);
            return;
          }
          console.log(`Invalid receipt: ${file.name}, Reason: ${reason}`);
          const id = await db.invalidReceipts.add({ filename: file.name, reason, data: text || "Unable to extract text" });
          setInvalidReceipts(prev => [...prev, { id, filename: file.name, reason, data: text || "Unable to extract text" }]);
          
          setPdfError(`Failed to process ${file.name}: ${userFriendlyMessage}`);
        }
      };

      // Handle PDF file upload (sequential processing)
      const handleFileUpload = async (files) => {
        const pdfFiles = Array.from(files).filter(f => f.type === "application/pdf" || f.name.endsWith(".pdf"));
        if (pdfFiles.length === 0) {
          setPdfError("Please upload files with a .pdf extension");
          return;
        }
        setPdfError("");
        for (const file of pdfFiles) {
          await processPDF(file);
        }
      };

      // PDF drag-and-drop handlers
      const handleDragOver = (e) => {
        e.preventDefault();
        setIsDragging(true);
      };

      const handleDragLeave = (e) => {
        e.preventDefault();
        setIsDragging(false);
      };

      const handleDrop = (e) => {
        e.preventDefault();
        setIsDragging(false);
        const files = e.dataTransfer.files;
        handleFileUpload(files);
      };

      // Manually assign receipt
      const assignReceipt = async (receiptId, studentId, amount) => {
        if (!studentId || isNaN(amount) || amount <= 0) {
          setError("Invalid student or amount");
          return;
        }
        const student = students.find(s => s.id === parseInt(studentId));
        const receipt = invalidReceipts.find(r => r.id === receiptId);
        const status = parseFloat(amount).toFixed(2) === student.expectedAmount ? "Paid" : "Incorrect";
        await db.students.update(student.id, { 
          paidAmount: parseFloat(amount).toFixed(2), 
          transactionDate: null,
          status, 
          pdfFilename: receipt.filename 
        });
        await db.invalidReceipts.delete(receiptId);
        setStudents(prev => prev.map(s => 
          s.id === student.id ? { ...s, paidAmount: parseFloat(amount).toFixed(2), transactionDate: null, status, pdfFilename: receipt.filename } : s
        ));
        setInvalidReceipts(prev => prev.filter(r => r.id !== receiptId));
      };

      // Delete payment
      const deletePayment = async (id) => {
        await db.students.update(id, { paidAmount: null, transactionDate: null, status: "No File Matched", pdfFilename: null });
        setStudents(prev => prev.map(s => 
          s.id === id ? { ...s, paidAmount: null, transactionDate: null, status: "No File Matched", pdfFilename: null } : s
        ));
      };

      // Delete invalid receipt
      const deleteInvalidReceipt = async (id) => {
        await db.invalidReceipts.delete(id);
        setInvalidReceipts(prev => prev.filter(r => r.id !== id));
      };

      // Export to CSV
      const exportToCSV = () => {
        const headers = ["Name", "Expected Amount", "Paid Amount", "Transaction Date", "Status", "PDF File"];
        const rows = students.map(s => [
          s.name,
          s.expectedAmount,
          s.paidAmount || "",
          s.transactionDate || "",
          s.status,
          s.pdfFilename || ""
        ]);
        const csv = [headers, ...rows].map(row => row.join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "payment_tracker.csv";
        a.click();
        URL.revokeObjectURL(url);
      };

      // Filter and sort students
      const filteredStudents = students.filter(s => 
        filter === "All" || s.status === filter
      ).sort((a, b) => {
        if (sortBy === "name-asc") return a.name.localeCompare(b.name);
        if (sortBy === "name-desc") return b.name.localeCompare(a.name);
        if (sortBy === "status-asc") return a.status.localeCompare(b.status);
        if (sortBy === "status-desc") return b.status.localeCompare(a.status);
      });

      if (!isAuthenticated) {
        return (
          <div className="min-h-screen flex items-center justify-center bg-gray-100">
            <div className="bg-white p-6 rounded shadow-md w-full max-w-md">
              <h1 className="text-2xl font-bold mb-4">Payment Tracker Login</h1>
              {error && <p className="text-red-500 mb-4">{error}</p>}
              <form onSubmit={handleLogin}>
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="Enter password"
                  className="w-full p-2 mb-4 border rounded"
                  required
                />
                <button type="submit" className="w-full bg-blue-400 text-white p-2 rounded-md shadow-sm hover:bg-blue-500 hover:bg-opacity-80 transition-colors duration-200">
                  Login
                </button>
              </form>
            </div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gray-100 p-4">
          <div className="max-w-6xl mx-auto">
            <div className="flex justify-between items-center mb-6">
              <h1 className="text-3xl font-bold">Payment Tracker</h1>
              <button
                onClick={handleLogout}
                className="bg-red-400 text-white p-2 rounded-md shadow-sm hover:bg-red-500 hover:bg-opacity-80 transition-colors duration-200"
              >
                Logout
              </button>
            </div>
            {error && <p className="text-red-500 mb-4">{error}</p>}

            {/* Add Student Form */}
            <div className="bg-white p-6 rounded shadow-md mb-6">
              <h2 className="text-xl font-bold mb-4">Add Student</h2>
              {/* Manual Entry Form */}
              <form onSubmit={addStudent} className="flex flex-col sm:flex-row gap-4 mb-6">
                <input
                  type="text"
                  value={newStudent.name}
                  onChange={(e) => setNewStudent({ ...newStudent, name: e.target.value })}
                  placeholder="Student Name"
                  className="p-2 border rounded flex-1"
                  required
                />
                <input
                  type="number"
                  value={newStudent.expectedAmount}
                  onChange={(e) => setNewStudent({ ...newStudent, expectedAmount: e.target.value })}
                  placeholder="Expected Amount (RM)"
                  step="0.01"
                  min="0"
                  className="p-2 border rounded flex-1"
                  required
                />
                <button type="submit" className="bg-blue-400 text-white p-2 rounded-md shadow-sm hover:bg-blue-500 hover:bg-opacity-80 transition-colors duration-200">
                  Add
                </button>
              </form>
              {/* CSV Upload */}
              <div
                className={`border-2 border-dashed rounded p-6 text-center ${
                  isDraggingCSV ? 'border-blue-500 bg-blue-100' : 'border-gray-300 bg-gray-50'
                }`}
                onDragOver={handleCSVDragOver}
                onDragLeave={handleCSVDragLeave}
                onDrop={handleCSVDrop}
              >
                <p className="mb-4">Drag and drop a CSV file with student names and expected amounts, or click to select</p>
                <input
                  type="file"
                  accept=".csv"
                  onChange={(e) => handleCSVUpload(e.target.files)}
                  className="hidden"
                  id="csvInput"
                />
                <label
                  htmlFor="csvInput"
                  className="bg-blue-400 text-white p-2 rounded-md shadow-sm hover:bg-blue-500 hover:bg-opacity-80 transition-colors duration-200 cursor-pointer"
                >
                  Select CSV File
                </label>
              </div>
            </div>

            {/* PDF Upload with Drag-and-Drop */}
            <div className="bg-white p-6 rounded shadow-md mb-6">
              <h2 className="text-xl font-bold mb-4">Upload Receipts</h2>
              {pdfError && <p className="text-red-500 mb-4">{pdfError}</p>}
              <div
                className={`border-2 border-dashed rounded p-6 text-center ${
                  isDragging ? 'border-blue-500 bg-blue-100' : 'border-gray-300 bg-gray-50'
                }`}
                onDragOver={handleDragOver}
                onDragLeave={handleDragLeave}
                onDrop={handleDrop}
              >
                <p className="mb-4">Drag and drop PDF files here or click to select</p>
                <input
                  type="file"
                  accept=".pdf"
                  multiple
                  onChange={(e) => handleFileUpload(e.target.files)}
                  className="hidden"
                  id="fileInput"
                />
                <label
                  htmlFor="fileInput"
                  className="bg-blue-400 text-white p-2 rounded-md shadow-sm hover:bg-blue-500 hover:bg-opacity-80 transition-colors duration-200 cursor-pointer"
                >
                  Select Files
                </label>
              </div>
            </div>

            {/* Dashboard */}
            <div className="bg-white p-6 rounded shadow-md mb-6">
              <h2 className="text-xl font-bold mb-4">Payment Status</h2>
              <div className="flex flex-col sm:flex-row gap-4 mb-4">
                <select
                  value={filter}
                  onChange={(e) => setFilter(e.target.value)}
                  className="p-2 border rounded"
                >
                  <option value="All">All</option>
                  <option value="Paid">Paid</option>
                  <option value="Unpaid">Unpaid</option>
                  <option value="Incorrect">Incorrect</option>
                  <option value="No File Matched">No File Matched</option>
                </select>
                <select
                  value={sortBy}
                  onChange={(e) => setSortBy(e.target.value)}
                  className="p-2 border rounded"
                >
                  <option value="name-asc">Name (A-Z)</option>
                  <option value="name-desc">Name (Z-A)</option>
                  <option value="status-asc">Status (A-Z)</option>
                  <option value="status-desc">Status (Z-A)</option>
                </select>
                <button
                  onClick={exportToCSV}
                  className="bg-green-400 text-white p-2 rounded-md shadow-sm hover:bg-green-500 hover:bg-opacity-80 transition-colors duration-200"
                >
                  Export to CSV
                </button>
              </div>
              <table className="w-full border-collapse">
                <thead>
                  <tr className="bg-gray-200">
                    <th className="border p-2">Name</th>
                    <th className="border p-2">Expected Amount</th>
                    <th className="border p-2">Paid Amount</th>
                    <th className="border p-2">Transaction Date</th>
                    <th className="border p-2">Status</th>
                    <th className="border p-2">PDF File</th>
                    <th className="border p-2">Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {filteredStudents.map(student => (
                    <tr key={student.id} className="hover:bg-gray-100">
                      <td className="border p-2">{student.name}</td>
                      <td className="border p-2">RM{student.expectedAmount}</td>
                      <td className="border p-2">{student.paidAmount ? `RM${student.paidAmount}` : "-"}</td>
                      <td className="border p-2">{student.transactionDate || "-"}</td>
                      <td className="border p-2">{student.status}</td>
                      <td className="border p-2">{student.pdfFilename || "-"}</td>
                      <td className="border p-2 flex gap-2">
                        <button
                          onClick={() => {
                            const newName = prompt("Enter new name", student.name);
                            const newAmount = prompt("Enter new expected amount", student.expectedAmount);
                            if (newName && newAmount) {
                              editStudent(student.id, {
                                name: newName,
                                expectedAmount: newAmount
                              });
                            }
                          }}
                          className="bg-yellow-300 text-white p-1 rounded-md shadow-sm hover:bg-yellow-400 hover:bg-opacity-80 transition-colors duration-200"
                        >
                          Edit
                        </button>
                        <button
                          onClick={() => deleteStudent(student.id)}
                          className="bg-red-400 text-white p-1 rounded-md shadow-sm hover:bg-red-500 hover:bg-opacity-80 transition-colors duration-200"
                        >
                          Delete
                        </button>
                        {student.paidAmount && (
                          <button
                            onClick={() => deletePayment(student.id)}
                            className="bg-gray-400 text-white p-1 rounded-md shadow-sm hover:bg-gray-500 hover:bg-opacity-80 transition-colors duration-200"
                          >
                            Clear Payment
                          </button>
                        )}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            {/* Invalid Receipts */}
            {invalidReceipts.length > 0 && (
              <div className="bg-white p-6 rounded shadow-md">
                <h2 className="text-xl font-bold mb-4">Invalid Receipts</h2>
                <table className="w-full border-collapse">
                  <thead>
                    <tr className="bg-gray-200">
                      <th className="border p-2">Filename</th>
                      <th className="border p-2">PDF Content</th>
                      <th className="border p-2">Reason</th>
                      <th className="border p-2">Assign</th>
                      <th className="border p-2">Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {invalidReceipts.map(receipt => (
                      <tr key={receipt.id} className="hover:bg-gray-100">
                        <td className="border p-2">{receipt.filename}</td>
                        <td className="border p-2">
                          <div className="text-sm text-gray-700 whitespace-pre-wrap">{formatPDFText(receipt.data)}</div>
                        </td>
                        <td className="border p-2">{receipt.reason}</td>
                        <td className="border p-2 flex gap-2">
                          <select
                            className="p-1 border rounded"
                            onChange={(e) => {
                              const amount = prompt("Enter amount");
                              if (amount) {
                                assignReceipt(receipt.id, e.target.value, amount);
                              }
                            }}
                          >
                            <option value="">Select Student</option>
                            {students.map(s => (
                              <option key={s.id} value={s.id}>{s.name}</option>
                            ))}
                          </select>
                        </td>
                        <td className="border p-2">
                          <button
                            onClick={() => deleteInvalidReceipt(receipt.id)}
                            className="bg-red-400 text-white p-1 rounded-md shadow-sm hover:bg-red-500 hover:bg-opacity-80 transition-colors duration-200"
                          >
                            Delete
                          </button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        </div>
      );
    }

    // Render the app
    ReactDOM.render(<App />, document.getElementById("root"));
  </script>
</body>
</html>
