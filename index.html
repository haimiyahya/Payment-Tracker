    const { useState, useEffect } = React;

    const db = new Dexie("PaymentTrackerDB");
    db.version(4).stores({
      students: "++id,name,expectedAmount,paidAmount,transactionDate,status,pdfFilename,sessionId",
      invalidReceipts: "++id,filename,reason,data,sessionId",
      settings: "key,value",
      paymentSessions: "++id,name",
      deletedSessions: "++id,name,students,invalidReceipts"
    });
    db.version(5).stores({
      payers: "++id,name,expectedAmount,paidAmount,transactionDate,status,pdfFilename,sessionId",
      invalidReceipts: "++id,filename,reason,data,sessionId",
      settings: "key,value",
      paymentSessions: "++id,name",
      deletedSessions: "++id,name,payers,invalidReceipts"
    }).upgrade(async (tx) => {
      console.log("Upgrading database from version 4 to 5");
      try {
        const students = await tx.table("students").toArray();
        if (students.length > 0) {
          console.log(`Migrating ${students.length} students to payers`);
          await tx.table("payers").bulkAdd(students);
          console.log("Migration completed: students copied to payers");
        }
        const deletedSessions = await tx.table("deletedSessions").toArray();
        if (deletedSessions.length > 0) {
          console.log(`Updating ${deletedSessions.length} deleted sessions`);
          await tx.table("deletedSessions").bulkPut(
            deletedSessions.map(session => ({
              ...session,
              payers: session.students || [],
              students: undefined
            }))
          );
          console.log("Migration completed: updated deletedSessions");
        }
        await tx.table("students").clear();
        console.log("Cleared old students table");
      } catch (err) {
        console.error("Error during database migration:", err);
      }
    });
    db.version(6).stores({
      payers: "++id,name,expectedAmount,paidAmount,transactionDate,status,pdfFilename,sessionId",
      invalidReceipts: "++id,filename,reason,data,pngData,sessionId",
      settings: "key,value",
      paymentSessions: "++id,name",
      deletedSessions: "++id,name,payers,invalidReceipts"
    }).upgrade(async (tx) => {
      console.log("Upgrading database from version 5 to 6");
      try {
        const invalidReceipts = await tx.table("invalidReceipts").toArray();
        if (invalidReceipts.length > 0) {
          console.log(`Updating ${invalidReceipts.length} invalid receipts to include pngData`);
          await tx.table("invalidReceipts").bulkPut(
            invalidReceipts.map(receipt => ({
              ...receipt,
              pngData: null
            }))
          );
          console.log("Migration completed: added pngData to invalidReceipts");
        }
      } catch (err) {
        console.error("Error during database migration to version 6:", err);
      }
    });

    const BM25 = {
      k1: 1.5,
      b: 0.75,
      threshold: 0.8,
      tokenize: (text) => text.toLowerCase().split(/\W+/).filter(t => t.length >= 2),
      computeScore: (query, doc, docLength, avgDocLength, idf) => {
        let score = 0;
        query.forEach(term => {
          const freq = doc.filter(t => t === term).length;
          const numerator = freq * (BM25.k1 + 1);
          const denominator = freq + BM25.k1 * (1 - BM25.b + BM25.b * (docLength / avgDocLength));
          score += idf[term] * numerator / denominator;
        });
        return score;
      },
      match: (query, documents) => {
        console.log(`BM25.match: Query=${query}, Documents=${JSON.stringify(documents.map(d => ({ id: d.id, name: d.name })))}`);
        const tokens = BM25.tokenize(query);
        console.log(`BM25.match: Query tokens=${tokens}`);
        const docTokens = documents.map(doc => ({
          id: doc.id,
          name: doc.name,
          tokens: BM25.tokenize(doc.name)
        }));
        console.log(`BM25.match: Doc tokens=${JSON.stringify(docTokens.map(dt => ({ id: dt.id, name: dt.name, tokens: dt.tokens })))}`);
        const docLengths = docTokens.map(dt => dt.tokens.length);
        const avgDocLength = docLengths.reduce((a, b) => a + b, 0) / docLengths.length || 1;
        const idf = {};
        tokens.forEach(term => {
          const docsWithTerm = docTokens.filter(dt => dt.tokens.includes(term)).length;
          idf[term] = Math.log((documents.length - docsWithTerm + 0.5) / (docsWithTerm + 0.5) + 1);
        });
        const scores = docTokens.map(dt => ({
          id: dt.id,
          name: dt.name,
          score: BM25.computeScore(tokens, dt.tokens, dt.tokens.length, avgDocLength, idf)
        }));
        console.log(`BM25.match: Scores=${JSON.stringify(scores)}`);
        const sorted = scores.sort((a, b) => b.score - a.score);
        if (sorted[0] && sorted[0].score > BM25.threshold) {
          const topScore = sorted[0].score;
          const closeScores = sorted.filter(s => s.score >= topScore * 0.9);
          if (closeScores.length === 1) {
            console.log(`BM25.match: Returning match=${JSON.stringify(sorted[0])}`);
            return sorted[0];
          }
        }
        console.log(`BM25.match: No match found`);
        return null;
      }
    };

    const formatPDFText = (text) => {
      if (!text || typeof text !== "string") return "No text available";
      let cleaned = text.replace(/[\x00-\x1F\x7F]+/g, " ");
      cleaned = cleaned.replace(/\s+/g, " ").trim();
      const amountRegex = /\RM?\d+\.\d{2}\b|\d+\s*RM\b/i;
      const dateRegex = /\b(\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\s+\d{2}:\d{2}:\d{2}|\d{1,2}[/-]\d{1,2}[/-]\d{2,4}(?:\s+\d{2}:\d{2}:\d{2})?|\d{4}[/-]\d{1,2}[/-]\d{1,2}(?:\s+\d{2}:\d{2}:\d{2})?)\b/i;
      const refNumberRegex = /\b\d{10}\b/;
      const otherDetailsRegex = /\bYURAN\s+(?:JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\s+\d{4}\b/;
      const amountMatch = cleaned.match(amountRegex);
      const dateMatch = cleaned.match(dateRegex);
      const refNumberMatch = cleaned.match(refNumberRegex);
      const otherDetailsMatch = cleaned.match(otherDetailsRegex);
      let prioritizedText = "";
      if (dateMatch) prioritizedText += `Date: ${dateMatch[0]}\n`;
      if (amountMatch) prioritizedText += `Amount: ${amountMatch[0]}\n`;
      if (refNumberMatch) prioritizedText += `Reference Number: ${refNumberMatch[0]}\n`;
      if (otherDetailsMatch) prioritizedText += `Other Transfer Details: ${otherDetailsMatch[0]}\n`;
      let remainingText = cleaned;
      if (amountMatch) remainingText = remainingText.replace(amountMatch[0], "").replace(/\s+/g, " ").trim();
      if (dateMatch) remainingText = remainingText.replace(dateMatch[0], "").replace(/\s+/g, " ").trim();
      if (refNumberMatch) remainingText = remainingText.replace(refNumberMatch[0], "").replace(/\s+/g, " ").trim();
      if (otherDetailsMatch) remainingText = remainingText.replace(otherDetailsMatch[0], "").replace(/\s+/g, " ").trim();
      prioritizedText += remainingText;
      if (prioritizedText.length > 500) {
        prioritizedText = prioritizedText.substring(0, 500) + "...";
      }
      return prioritizedText || "No text available";
    };

    const convertPDFToPNG = async (file) => {
      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({ scale: 1.0 });
        const scale = 400 / viewport.width;
        const scaledViewport = page.getViewport({ scale });
        const canvas = document.createElement("canvas");
        canvas.width = scaledViewport.width;
        canvas.height = scaledViewport.height;
        const context = canvas.getContext("2d");
        await page.render({
          canvasContext: context,
          viewport: scaledViewport
        }).promise;
        const pngData = canvas.toDataURL("image/png");
        return pngData;
      } catch (err) {
        console.error(`Error converting PDF ${file.name} to PNG:`, err);
        return null;
      }
    };

    function ImageModal({ isOpen, onClose, imageSrc }) {
      if (!isOpen || !imageSrc) return null;

      return (
        <div
          className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
          onClick={onClose}
        >
          <div
            className="bg-white p-2 rounded-lg shadow-xl max-w-2xl w-full relative"
            onClick={e => e.stopPropagation()}
          >
            <button
              onClick={onClose}
              className="absolute top-1 right-1 text-gray-600 hover:text-gray-800 text-sm"
            >
              ×
            </button>
            <h3 className="text-xs font-semibold text-gray-800 mb-1">Receipt Preview</h3>
            <img
              src={imageSrc}
              alt="Receipt Preview"
              className="max-w-[300px] h-auto rounded shadow-sm"
            />
          </div>
        </div>
      );
    }

    function SessionsModal({ isOpen, onClose, sessions, deletedSessions, currentSession, setSessions, setDeletedSessions, setCurrentSession, setPayers, setInvalidReceipts, setError, setIsLoading, newSessionName, setNewSessionName, openSession, createNewSession, deleteSession, restoreSession, permanentlyDeleteSession, clearTrashBin }) {
      if (!isOpen) return null;

      const mustCreateSession = sessions.length === 0 && !currentSession;

      return (
        <div
          className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
          onClick={mustCreateSession ? null : onClose}
        >
          <div
            className="bg-white p-3 rounded-lg shadow-xl max-w-lg w-full relative"
            onClick={e => e.stopPropagation()}
          >
            <button
              onClick={onClose}
              className={`absolute top-1 right-1 text-gray-600 hover:text-gray-800 text-sm ${mustCreateSession ? 'opacity-50 cursor-not-allowed' : ''}`}
              disabled={mustCreateSession}
            >
              ×
            </button>
            <h2 className="text-base font-semibold text-gray-800 mb-2">Payment Sessions</h2>
            {mustCreateSession && (
              <p className="text-red-500 mb-2 text-xs">Please create a session to continue.</p>
            )}
            <div className="flex flex-col sm:flex-row gap-1 mb-2">
              <input
                type="text"
                value={newSessionName}
                onChange={(e) => setNewSessionName(e.target.value)}
                placeholder="New Session Name (e.g., Book Payments)"
                className="p-1 border border-gray-200 rounded flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs"
              />
              <button
                onClick={createNewSession}
                className="bg-blue-600 text-white px-2 py-1 rounded shadow-md hover:bg-blue-700 hover:shadow-lg transition-all duration-300 text-xs"
              >
                New Session
              </button>
              <select
                onChange={(e) => openSession(e.target.value)}
                className="p-1 border border-gray-200 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs"
                value={currentSession ? currentSession.id : ""}
              >
                {sessions.length === 0 && (
                  <option value="">Select a Session</option>
                )}
                {sessions.map(session => (
                  <option key={session.id} value={session.id}>{session.name}</option>
                ))}
              </select>
              {currentSession && (
                <button
                  onClick={deleteSession}
                  className="bg-red-500 text-white px-2 py-1 rounded shadow-md hover:bg-red-600 hover:shadow-lg transition-all duration-300 text-xs"
                >
                  Delete Session
                </button>
              )}
            </div>
            {deletedSessions.length > 0 && (
              <div id="trash-bin" className="bg-gray-50 p-3 rounded-lg shadow-sm">
                <div className="flex justify-between items-center mb-2">
                  <h2 className="text-base font-semibold text-gray-800">Trash Bin</h2>
                  <button
                    onClick={clearTrashBin}
                    className="bg-red-600 text-white px-2 py-1 rounded shadow-md hover:bg-red-600 hover:shadow-lg transition-all duration-300 text-xs"
                  >
                    Clear Trash Bin
                  </button>
                </div>
                <div className="overflow-x-auto">
                  <table className="w-full border-collapse">
                    <thead>
                      <tr className="bg-gray-100">
                        <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Session Name</th>
                        <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Actions</th>
                      </tr>
                    </thead>
                    <tbody>
                      {deletedSessions.map(session => (
                        <tr key={session.id} className="hover:bg-gray-50">
                          <td className="border-b border-gray-200 p-1 text-gray-700 text-xs">{session.name}</td>
                          <td className="border-b border-gray-200 p-1 flex gap-1">
                            <button
                              onClick={() => restoreSession(session.id)}
                              className="bg-green-600 text-white px-1 py-1 rounded shadow-sm hover:bg-green-700 hover:shadow-md transition-all duration-300 text-xs"
                            >
                              Restore
                            </button>
                            <button
                              onClick={() => permanentlyDeleteSession(session.id)}
                              className="bg-red-500 text-white px-1 py-1 rounded shadow-sm hover:bg-red-600 hover:shadow-md transition-all duration-300 text-xs"
                            >
                              Permanently Delete
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    function NavBar({ isAuthenticated, currentSession, handleLogout, scrollToSection, openSessionsModal }) {
      const [isOpen, setIsOpen] = useState(false);
      const navItems = [
        { name: "Home", section: "dashboard" },
        { name: "Sessions", action: openSessionsModal },
        { name: "Logout", action: handleLogout },
      ];

      return (
        <nav className="bg-blue-600 text-white fixed top-0 left-0 w-full z-40 shadow-md">
          <div className="max-w-5xl mx-auto px-2">
            <div className="flex justify-between items-center h-10">
              <div className="flex-shrink-0">
                <h1 className="text-base font-bold">Payment Tracker</h1>
              </div>
              <div className="hidden sm:flex sm:space-x-1">
                {isAuthenticated && navItems.map((item) => (
                  item.action ? (
                    <button key={item.name} onClick={item.action} className="px-1 py-1 rounded text-xs font-medium hover:bg-blue-700 transition-colors" >
                      {item.name}
                    </button>
                  ) : (
                    <button key={item.name} onClick={() => scrollToSection(item.section)} className="px-1 py-1 rounded text-xs font-medium hover:bg-blue-700 transition-colors" >
                      {item.name}
                    </button>
                  )
                ))}
              </div>
              <div className="sm:hidden">
                <button onClick={() => setIsOpen(!isOpen)} className="text-white hover:bg-blue-700 p-1 rounded focus:outline-none" >
                  <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" >
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d={isOpen ? "M6 18L18 6M6 6l12 12" : "M4 6h16M4 12h16m-7 6h7"} />
                  </svg>
                </button>
              </div>
            </div>
            {isOpen && (
              <div className="sm:hidden">
                <div className="px-2 pt-1 pb-2 space-y-1">
                  {isAuthenticated && navItems.map((item) => (
                    item.action ? (
                      <button key={item.name} onClick={() => { item.action(); setIsOpen(false); }} className="block px-1 py-1 rounded text-xs font-medium hover:bg-blue-700 w-full text-left" >
                        {item.name}
                      </button>
                    ) : (
                      <button key={item.name} onClick={() => { scrollToSection(item.section); setIsOpen(false); }} className="block px-1 py-1 rounded text-xs font-medium hover:bg-blue-700 w-full text-left" >
                        {item.name}
                      </button>
                    )
                  ))}
                </div>
              </div>
            )}
          </div>
        </nav>
      );
    }

    // New Print Preview Modal Component
    function PrintPreviewModal({ isOpen, onClose, pdfDataUrl, orientation, setOrientation, colorMode, setColorMode, zoom, setZoom, printDocument }) {
      if (!isOpen) return null;

      const iframeStyle = {
        width: '100%',
        height: '80vh',
        transform: `scale(${zoom / 100})`,
        transformOrigin: '0 0'
      };

      return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-4 rounded-lg shadow-xl max-w-4xl w-full relative">
            <h2 className="text-lg font-semibold mb-2">Print Preview</h2>

            <div className="mb-4 flex items-center gap-2">
              <label htmlFor="orientation" className="text-sm">Orientation:</label>
              <select id="orientation" className="border rounded p-1 text-xs" value={orientation} onChange={(e) => setOrientation(e.target.value)}>
                <option value="portrait">Portrait</option>
                <option value="landscape">Landscape</option>
              </select>

              <label htmlFor="colorMode" className="text-sm">Color:</label>
              <select id="colorMode" className="border rounded p-1 text-xs" value={colorMode} onChange={(e) => setColorMode(e.target.value)}>
                <option value="color">Color</option>
                <option value="grayscale">Grayscale</option>
              </select>

              <label htmlFor="zoom" className="text-sm">Zoom:</label>
              <select id="zoom" className="border rounded p-1 text-xs" value={zoom} onChange={(e) => setZoom(parseInt(e.target.value))}>
                <option value="50">50%</option>
                <option value="75">75%</option>
                <option value="100">100%</option>
                <option value="125">125%</option>
                <option value="150">150%</option>
              </select>
            </div>

            <iframe src={pdfDataUrl} style={iframeStyle} title="Print Preview" />

            <div className="mt-4 flex justify-end gap-2">
              <button className="bg-gray-300 hover:bg-gray-400 px-2 py-1 rounded text-sm" onClick={onClose}>Cancel</button>
              <button className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm" onClick={printDocument}>Print</button>
            </div>
          </div>
        </div>
      );
    }

    function App() {
      const [isAuthenticated, setIsAuthenticated] = useState(false);
      const [password, setPassword] = useState("");
      const [error, setError] = useState("");
      const [pdfError, setPdfError] = useState("");
      const [payers, setPayers] = useState([]);
      const [invalidReceipts, setInvalidReceipts] = useState([]);
      const [sessions, setSessions] = useState([]);
      const [deletedSessions, setDeletedSessions] = useState([]);
      const [currentSession, setCurrentSession] = useState(null);
      const [newSessionName, setNewSessionName] = useState("");
      const [isModalOpen, setIsModalOpen] = useState(false);
      const [selectedImage, setSelectedImage] = useState(null);
      const [isSessionsModalOpen, setIsSessionsModalOpen] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [searchTerm, setSearchTerm] = useState("");
      const [selectedPayers, setSelectedPayers] = useState([]);
      const [isPrintPreviewOpen, setIsPrintPreviewOpen] = useState(false);
      const [pdfDataUrl, setPdfDataUrl] = useState(null);
      const [printOrientation, setPrintOrientation] = useState('portrait');
      const [printColorMode, setPrintColorMode] = useState('color');
      const [printZoom, setPrintZoom] = useState(100);
      const [sortConfig, setSortConfig] = useState({ key: 'name', direction: 'ascending' });
      const [filterConfig, setFilterConfig] = useState('all');
      const [autoLogoutInterval, setAutoLogoutInterval] = useState(null);

      const openModal = (imageSrc) => {
        setSelectedImage(imageSrc);
        setIsModalOpen(true);
      };

      const closeModal = () => {
        setIsModalOpen(false);
        setSelectedImage(null);
      };

      const openSessionsModal = () => {
        setIsSessionsModalOpen(true);
      };

      const closeSessionsModal = () => {
        setIsSessionsModalOpen(false);
      };

      const loadData = async () => {
        setIsLoading(true);
        try {
          const savedPassword = await db.settings.get("password");
          if (savedPassword && savedPassword.value) {
            setPassword(savedPassword.value);
            setIsAuthenticated(true);
          }
          const currentSessionId = await db.settings.get("currentSession");
          if (currentSessionId && currentSessionId.value) {
            const session = await db.paymentSessions.get(currentSessionId.value);
            if (session) {
              setCurrentSession(session);
              const payersData = await db.payers.where("sessionId").equals(session.id).toArray();
              setPayers(payersData);
              const invalidReceiptsData = await db.invalidReceipts.where("sessionId").equals(session.id).toArray();
              setInvalidReceipts(invalidReceiptsData);
            }
          }
          const sessionsData = await db.paymentSessions.toArray();
          setSessions(sessionsData);
          const deletedSessionsData = await db.deletedSessions.toArray();
          setDeletedSessions(deletedSessionsData);
        } catch (error) {
          setError("Failed to load data from database");
          console.error("Database Error:", error);
        } finally {
          setIsLoading(false);
        }
      };

      useEffect(() => {
        loadData();
      }, []);

      useEffect(() => {
        if (isAuthenticated) {
          const interval = setInterval(() => {
            handleLogout();
            setError("Session timed out due to inactivity.");
          }, 1800000);
          setAutoLogoutInterval(interval);
          return () => clearInterval(interval);
        }
      }, [isAuthenticated]);

      const scrollToSection = (sectionId) => {
        const element = document.getElementById(sectionId);
        if (element) {
          element.scrollIntoView({ behavior: "smooth" });
        }
      };

      const resetSessionTimeout = () => {
        if (autoLogoutInterval) {
          clearInterval(autoLogoutInterval);
          const interval = setInterval(() => {
            handleLogout();
            setError("Session timed out due to inactivity.");
          }, 1800000);
          setAutoLogoutInterval(interval);
        }
      };

      useEffect(() => {
        window.addEventListener('mousemove', resetSessionTimeout);
        window.addEventListener('keydown', resetSessionTimeout);

        return () => {
          window.removeEventListener('mousemove', resetSessionTimeout);
          window.removeEventListener('keydown', resetSessionTimeout);
          if (autoLogoutInterval) {
            clearInterval(autoLogoutInterval);
          }
        };
      }, [autoLogoutInterval]);

      const handleLogin = async () => {
        setIsLoading(true);
        setError("");
        try {
          const savedPassword = await db.settings.get("password");
          if (savedPassword && savedPassword.value === password) {
            setIsAuthenticated(true);
            const currentSessionId = await db.settings.get("currentSession");
            if (currentSessionId && currentSessionId.value) {
              const session = await db.paymentSessions.get(currentSessionId.value);
              if (session) {
                setCurrentSession(session);
                const payersData = await db.payers.where("sessionId").equals(session.id).toArray();
                setPayers(payersData);
                const invalidReceiptsData = await db.invalidReceipts.where("sessionId").equals(session.id).toArray();
                setInvalidReceipts(invalidReceiptsData);
              }
            }
          } else {
            setError("Invalid password");
            setIsAuthenticated(false);
          }
        } catch (err) {
          setError("Login failed. Please try again.");
          console.error("Login error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const handleLogout = async () => {
        setIsAuthenticated(false);
        setCurrentSession(null);
        setPayers([]);
        setInvalidReceipts([]);
        try {
          await db.settings.delete("currentSession");
        } catch (err) {
          setError("Logout failed.");
          console.error("Logout error:", err);
        }
      };

      const createNewSession = async () => {
        setIsLoading(true);
        setError("");
        if (!newSessionName.trim()) {
          setError("Session name cannot be empty.");
          setIsLoading(false);
          return;
        }
        try {
          const existingSession = await db.paymentSessions.where("name").equals(newSessionName).first();
          if (existingSession) {
            setError("A session with this name already exists.");
            setIsLoading(false);
            return;
          }
          const newSessionId = await db.paymentSessions.add({ name: newSessionName });
          const newSession = { id: newSessionId, name: newSessionName };
          setSessions([...sessions, newSession]);
          setCurrentSession(newSession);
          setNewSessionName("");
          await db.settings.put({ key: "currentSession", value: newSessionId });
          setPayers([]);
          setInvalidReceipts([]);
        } catch (err) {
          setError("Failed to create new session.");
          console.error("Create session error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const openSession = async (sessionId) => {
        setIsLoading(true);
        setError("");
        try {
          const session = await db.paymentSessions.get(parseInt(sessionId));
          if (!session) {
            setError("Session not found.");
            setIsLoading(false);
            return;
          }
          setCurrentSession(session);
          await db.settings.put({ key: "currentSession", value: parseInt(sessionId) });
          const payersData = await db.payers.where("sessionId").equals(parseInt(sessionId)).toArray();
          setPayers(payersData);
          const invalidReceiptsData = await db.invalidReceipts.where("sessionId").equals(parseInt(sessionId)).toArray();
          setInvalidReceipts(invalidReceiptsData);
          closeSessionsModal();
        } catch (err) {
          setError("Failed to open session.");
          console.error("Open session error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const deleteSession = async () => {
        setIsLoading(true);
        setError("");
        if (!currentSession) {
          setError("No session selected to delete.");
          setIsLoading(false);
          return;
        }
        try {
          const sessionToDelete = await db.paymentSessions.get(currentSession.id);
          if (!sessionToDelete) {
            setError("Session to delete not found.");
            setIsLoading(false);
            return;
          }
          const sessionPayers = await db.payers.where("sessionId").equals(currentSession.id).toArray();
          const sessionInvalidReceipts = await db.invalidReceipts.where("sessionId").equals(currentSession.id).toArray();
          await db.deletedSessions.add({
            name: sessionToDelete.name,
            payers: sessionPayers,
            invalidReceipts: sessionInvalidReceipts
          });
          await db.payers.where("sessionId").equals(currentSession.id).delete();
          await db.invalidReceipts.where("sessionId").equals(currentSession.id).delete();
          await db.paymentSessions.delete(currentSession.id);
          setSessions(sessions.filter(s => s.id !== currentSession.id));
          setCurrentSession(null);
          setPayers([]);
          setInvalidReceipts([]);
          await db.settings.delete("currentSession");
          closeSessionsModal();
        } catch (err) {
          setError("Failed to delete session.");
          console.error("Delete session error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const restoreSession = async (sessionId) => {
        setIsLoading(true);
        setError("");
        try {
          const sessionToRestore = await db.deletedSessions.get(sessionId);
          if (!sessionToRestore) {
            setError("Session to restore not found.");
            setIsLoading(false);
            return;
          }
          const newSessionId = await db.paymentSessions.add({ name: sessionToRestore.name });
          const restoredSession = { id: newSessionId, name: sessionToRestore.name };
          await db.settings.put({ key: "currentSession", value: newSessionId });
          await db.payers.bulkAdd(sessionToRestore.payers.map(p => ({ ...p, sessionId: newSessionId })));
          await db.invalidReceipts.bulkAdd(sessionToRestore.invalidReceipts.map(r => ({ ...r, sessionId: newSessionId })));
          setSessions([...sessions, restoredSession]);
          setDeletedSessions(deletedSessions.filter(s => s.id !== sessionId));
          setCurrentSession(restoredSession);
          setPayers(sessionToRestore.payers);
          setInvalidReceipts(sessionToRestore.invalidReceipts);
        } catch (err) {
          setError("Failed to restore session.");
          console.error("Restore session error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const permanentlyDeleteSession = async (sessionId) => {
        setIsLoading(true);
        setError("");
        try {
          await db.deletedSessions.delete(sessionId);
          setDeletedSessions(deletedSessions.filter(s => s.id !== sessionId));
        } catch (err) {
          setError("Failed to permanently delete session.");
          console.error("Permanently delete session error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const clearTrashBin = async () => {
        setIsLoading(true);
        setError("");
        try {
          await db.deletedSessions.clear();
          setDeletedSessions([]);
        } catch (err) {
          setError("Failed to clear trash bin.");
          console.error("Clear trash bin error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const addPayer = async (newPayer) => {
        setIsLoading(true);
        setError("");
        try {
          if (!currentSession) {
            setError("Please select a session before adding payers.");
            setIsLoading(false);
            return;
          }
          const existingPayer = await db.payers.where('name').equalsIgnoreCase(newPayer.name).and(p => p.sessionId === currentSession.id).first();
          if (existingPayer) {
            setError('Payer with this name already exists in the current session.');
            setIsLoading(false);
            return;
          }
          const id = await db.payers.add({ ...newPayer, sessionId: currentSession.id });
          const addedPayer = { ...newPayer, id };
          setPayers([...payers, addedPayer]);
        } catch (err) {
          setError("Failed to add payer.");
          console.error("Add payer error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const processCSV = async (file) => {
        setIsLoading(true);
        setError("");
        try {
          const text = await file.text();
          Papa.parse(text, {
            header: true,
            complete: async (results) => {
              if (results.errors.length > 0) {
                setError("Error parsing CSV file. Please check the format.");
                setIsLoading(false);
                return;
              }
              if (!currentSession) {
                setError("Please select a session before uploading CSV.");
                setIsLoading(false);
                return;
              }
              const validPayers = [];
              const invalidData = [];
              for (const row of results.data) {
                if (row.Name && row["Expected Amount (RM)"]) {
                  const expectedAmount = parseFloat(row["Expected Amount (RM)"]);
                  if (isNaN(expectedAmount)) {
                    invalidData.push({
                      filename: file.name,
                      reason: "Invalid amount format",
                      data: row
                    });
                    continue;
                  }
                  let paidAmount = row["Paid Amount (RM)"] ? parseFloat(row["Paid Amount (RM)"]) : 0;
                  if (isNaN(paidAmount)) {
                    invalidData.push({
                      filename: file.name,
                      reason: "Invalid paid amount format",
                      data: row
                    });
                    continue;
                  }
                  let transactionDate = row["Transaction Date"] || "";
                  let status = row.Status || "Not Paid";
                  if (status.toLowerCase() !== "paid" && status.toLowerCase() !== "not paid") {
                    invalidData.push({
                      filename: file.name,
                      reason: "Invalid status",
                      data: row
                    });
                    continue;
                  }
                  if (status.toLowerCase() === "paid" && !transactionDate) {
                    invalidData.push({
                      filename: file.name,
                      reason: "Transaction date required for paid status",
                      data: row
                    });
                    continue;
                  }
                  validPayers.push({
                    name: row.Name,
                    expectedAmount: expectedAmount,
                    paidAmount: paidAmount,
                    transactionDate: transactionDate,
                    status: status,
                    sessionId: currentSession.id
                  });
                } else {
                  invalidData.push({
                    filename: file.name,
                    reason: "Missing required fields (Name or Expected Amount)",
                    data: row
                  });
                }
              }
              if (validPayers.length > 0) {
                await db.payers.bulkAdd(validPayers);
                setPayers([...payers, ...validPayers]);
              }
              if (invalidData.length > 0) {
                await db.invalidReceipts.bulkAdd(invalidData.map(item => ({ ...item, sessionId: currentSession.id })));
                setInvalidReceipts([...invalidReceipts, ...invalidData]);
              }
              if (validPayers.length === 0 && invalidData.length > 0) {
                setError("No valid payers found in the CSV file.");
              }
              if (validPayers.length > 0 && invalidData.length > 0) {
                setError("Some payers were invalid and not added.");
              }
            }
          });
        } catch (err) {
          setError("Failed to process CSV file.");
          console.error("CSV processing error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const handleCSVUpload = (event) => {
        const file = event.target.files[0];
        if (file) {
          processCSV(file);
        }
      };

      const handleCSVDragOver = (event) => {
        event.preventDefault();
        event.stopPropagation();
      };

      const handleCSVDragLeave = (event) => {
        event.preventDefault();
        event.stopPropagation();
      };

      const handleCSVDrop = (event) => {
        event.preventDefault();
        event.stopPropagation();
        const file = event.dataTransfer.files[0];
        if (file) {
          processCSV(file);
        }
      };

      const editPayer = async (id, updatedPayer) => {
        setIsLoading(true);
        setError("");
        try {
          await db.payers.update(id, updatedPayer);
          setPayers(payers.map(p => p.id === id ? { ...p, ...updatedPayer } : p));
        } catch (err) {
          setError("Failed to edit payer.");
          console.error("Edit payer error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const deletePayer = async (id) => {
        setIsLoading(true);
        setError("");
        try {
          await db.payers.delete(id);
          setPayers(payers.filter(p => p.id !== id));
        } catch (err) {
          setError("Failed to delete payer.");
          console.error("Delete payer error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const validatePDFFile = async (file) => {
        setIsLoading(true);
        setError("");
        setPdfError("");
        try {
          const arrayBuffer = await file.arrayBuffer();
          const pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
          let textContent = "";
          for (let i = 1; i <= pdfDoc.numPages; i++) {
            const page = await pdfDoc.getPage(i);
            const text = await page.getTextContent();
            const pageText = text.items.map(item => item.str).join(" ");
            textContent += pageText + " ";
          }
          if (textContent.length < 10) {
            setPdfError("PDF file does not contain enough text.");
            setIsLoading(false);
            return null;
          }
          const pngData = await convertPDFToPNG(file);
          setIsLoading(false);
          return { text: textContent, pngData };
        } catch (err) {
          setPdfError("Error processing PDF file. Please ensure it is a valid PDF.");
          console.error("PDF processing error:", err);
          setIsLoading(false);
          return null;
        }
      };

      const processPDF = async (file, payerName) => {
        setIsLoading(true);
        setError("");
        setPdfError("");
        try {
          const validationResult = await validatePDFFile(file);
          if (!validationResult) {
            setIsLoading(false);
            return;
          }
          const { text, pngData } = validationResult;
          const existingPayer = payers.find(p => p.name.toLowerCase() === payerName.toLowerCase());
          if (!existingPayer) {
            setError(`Payer "${payerName}" does not exist. Please add the payer first.`);
            setIsLoading(false);
            return;
          }
          const match = BM25.match(payerName, [existingPayer]);
          if (!match || match.id !== existingPayer.id) {
            setError(`Could not find a matching payer for "${payerName}". Please ensure the name is correct.`);
            setIsLoading(false);
            return;
          }
          const formattedText = formatPDFText(text);
          const newPayerData = {
            name: payerName,
            expectedAmount: existingPayer.expectedAmount,
            paidAmount: existingPayer.paidAmount,
            transactionDate: existingPayer.transactionDate,
            status: "Paid",
            pdfFilename: file.name,
          };
          await editPayer(existingPayer.id, newPayerData);
          await db.invalidReceipts.add({
            filename: file.name,
            reason: "Valid Receipt",
            data: formattedText,
            pngData: pngData,
            sessionId: currentSession.id
          });
          setPayers(payers.map(p => p.id === existingPayer.id ? { ...p, ...newPayerData } : p));
        } catch (err) {
          setError("Failed to process PDF and update payer.");
          console.error("PDF processing error:", err);
        } finally {
          setIsLoading(false);
        }
      };

      const handlePDFUpload = (event, payerName) => {
        const file = event.target.files[0];
        if (file) {
          processPDF(file, payerName);
        }
      };

      const handlePDFDragOver = (event) => {
        event.preventDefault();
        event.stopPropagation();
      };

      const handlePDFDragLeave = (event) => {
        event.preventDefault();
        event.stopPropagation();
      };

      const handlePDFDrop = (event, payerName) => {
        event.preventDefault();
        event.stopPropagation();
        const file = event.dataTransfer.files[0];
        if (file) {
          processPDF(file, payerName);
        }
      };

      const filterPayers = (term) => {
        setSearchTerm(term);
      };

      const sortPayers = (key) => {
        let direction = 'ascending';
        if (sortConfig.key === key && sortConfig.direction === 'ascending') {
          direction = 'descending';
        }
        setSortConfig({ key, direction });
      };

      const sortedAndFilteredPayers = () => {
        let result = [...payers];
        if (searchTerm) {
          const searchTermLower = searchTerm.toLowerCase();
          result = result.filter(payer =>
            payer.name.toLowerCase().includes(searchTermLower) ||
            payer.status.toLowerCase().includes(searchTermLower)
          );
        }
        if (filterConfig !== 'all') {
          result = result.filter(payer => payer.status.toLowerCase() === filterConfig);
        }
        if (sortConfig !== null) {
          result.sort((a, b) => {
            if (a[sortConfig.key] < b[sortConfig.key]) {
              return sortConfig.direction === 'ascending' ? -1 : 1;
            }
            if (a[sortConfig.key] > b[sortConfig.key]) {
              return sortConfig.direction === 'ascending' ? 1 : -1;
            }
            return 0;
          });
        }
        return result;
      };

      const generatePDF = async (payersToPrint, orientation = 'portrait', colorMode = 'color') => { // Added parameters
        if (payersToPrint.length === 0) {
          setError("No payers selected to generate PDF");
          return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
          orientation: orientation, // Use parameter
          unit: "mm",
          format: "a4",
          compress: true
        });

        // ... (Your existing PDF generation logic, modified to use orientation and colorMode if needed)
        // Example:
        doc.setFontSize(12);
        doc.setTextColor(colorMode === 'color' ? '#000000' : '#808080'); // Example: Change text color based on mode

        // AutoTable configuration
        const tableConfig = {
          head: [['Name', 'Expected Amount (RM)', 'Paid Amount (RM)', 'Transaction Date', 'Status']],
          body: payersToPrint.map(payer => [
            payer.name,
            payer.expectedAmount,
            payer.paidAmount ? payer.paidAmount : '-',
            payer.transactionDate ? payer.transactionDate : '-',
            payer.status
          ]),
          styles: {
            cellPadding: 1,
            fontSize: 8,
            overflow: 'linebreak',
            fontStyle: 'normal'
          },
          columnStyles: {
            0: { cellWidth: 40 },
            1: { cellWidth: 25 },
            2: { cellWidth: 25 },
            3: { cellWidth: 35 },
            4: { cellWidth: 25 }
          }
        };

        doc.autoTable(tableConfig);

        const pdfBlob = doc.output('blob');
        const pdfUrl = URL.createObjectURL(pdfBlob);
        setPdfDataUrl(pdfUrl);
        setIsPrintPreviewOpen(true);
      };

      const handlePrint = () => {
        if (pdfDataUrl) {
          window.print(); // Trigger browser's print dialog
        }
      };

      const handlePrintButtonClick = (selectedPayers) => {
        generatePDF(selectedPayers, printOrientation, printColorMode);
      };

      const togglePayerSelection = (payerId) => {
        setSelectedPayers(prevSelected =>
          prevSelected.includes(payerId)
            ? prevSelected.filter(id => id !== payerId)
            : [...prevSelected, payerId]
        );
      };

      const toggleSelectAllPayers = () => {
        if (selectedPayers.length === sortedAndFilteredPayers().length) {
          setSelectedPayers([]);
        } else {
          setSelectedPayers(sortedAndFilteredPayers().map(payer => payer.id));
        }
      };

      return (
        <div>
          <NavBar
            isAuthenticated={isAuthenticated}
            currentSession={currentSession}
            handleLogout={handleLogout}
            scrollToSection={scrollToSection}
            openSessionsModal={openSessionsModal}
          />
          {isLoading && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
              <div className="text-white text-lg">Loading...</div>
            </div>
          )}
          {!isAuthenticated && (
            <div id="login" className="container mx-auto mt-20 p-4 flex flex-col items-center">
              <h2 className="text-2xl font-semibold mb-4 text-gray-800">Login</h2>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Enter password"
                className="p-2 border border-gray-300 rounded w-64 mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-sm"
              />
              <button
                onClick={handleLogin}
                className="bg-blue-600 text-white px-4 py-2 rounded shadow-md hover:bg-blue-700 hover:shadow-lg transition-all duration-300 w-64 text-sm"
                disabled={isLoading}
              >
                {isLoading ? "Logging in..." : "Login"}
              </button>
              {error && <p className="text-red-500 mt-2 text-xs">{error}</p>}
            </div>
          )}

          {isAuthenticated && (
            <div id="dashboard" className="container mx-auto mt-12 p-4">
              <SessionsModal
                isOpen={isSessionsModalOpen}
                onClose={closeSessionsModal}
                sessions={sessions}
                deletedSessions={deletedSessions}
                currentSession={currentSession}
                setSessions={setSessions}
                setDeletedSessions={setDeletedSessions}
                setCurrentSession={setCurrentSession}
                setPayers={setPayers}
                setInvalidReceipts={setInvalidReceipts}
                setError={setError}
                setIsLoading={setIsLoading}
                newSessionName={newSessionName}
                setNewSessionName={setNewSessionName}
                openSession={openSession}
                createNewSession={createNewSession}
                deleteSession={deleteSession}
                restoreSession={restoreSession}
                permanentlyDeleteSession={permanentlyDeleteSession}
                clearTrashBin={clearTrashBin}
              />
              <h2 className="text-xl font-semibold mb-4text-gray-800">Dashboard</h2>
              {currentSession && (
                <div className="mb-4 p-3 bg-gray-100 rounded-md shadow-sm border border-gray-200">
                  <p className="text-sm text-gray-700">Current Session: <span className="font-semibold text-blue-600">{currentSession.name}</span></p>
                </div>
              )}
              {error && <p className="text-red-500 mb-2 text-xs">{error}</p>}
              <div className="mb-6 bg-white p-4 rounded-lg shadow-md">
                <h3 className="text-lg font-semibold mb-3 text-gray-800">Payer Input Form</h3>
                <form
                  onSubmit={(e) => {
                    e.preventDefault();
                    const name = e.target.name.value;
                    const expectedAmount = parseFloat(e.target.expectedAmount.value);
                    if (name && !isNaN(expectedAmount)) {
                      addPayer({ name, expectedAmount, paidAmount: 0, transactionDate: "", status: "Not Paid" });
                      e.target.name.value = "";
                      e.target.expectedAmount.value = "";
                    } else {
                      setError("Please enter a valid name and amount.");
                    }
                  }}
                  className="flex flex-col sm:flex-row gap-2"
                >
                  <input
                    type="text"
                    name="name"
                    placeholder="Payer Name"
                    required
                    className="p-2 border border-gray-200 rounded flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs"
                  />
                  <input
                    type="number"
                    name="expectedAmount"
                    placeholder="Expected Amount (RM)"
                    required
                    className="p-2 border border-gray-200 rounded flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs"
                  />
                  <button
                    type="submit"
                    className="bg-green-600 text-white px-4 py-2 rounded shadow-md hover:bg-green-700 hover:shadow-lg transition-all duration-300 text-xs"
                    disabled={isLoading}
                  >
                    {isLoading ? "Adding..." : "Add Payer"}
                  </button>
                </form>
              </div>

              <div className="mb-6 bg-white p-4 rounded-lg shadow-md">
                <h3 className="text-lg font-semibold mb-3 text-gray-800">Bulk Upload (CSV)</h3>
                <div
                  onDrop={handleCSVDrop}
                  onDragOver={handleCSVDragOver}
                  onDragLeave={handleCSVDragLeave}
                  className="border-2 border-dashed border-gray-300 rounded-md p-4 text-center cursor-pointer hover:border-blue-500 transition-colors text-xs"
                >
                  <p>Drag and drop CSV file here, or click to select file.</p>
                  <input
                    type="file"
                    accept=".csv"
                    onChange={handleCSVUpload}
                    className="hidden"
                    id="csv-upload"
                  />
                  <label htmlFor="csv-upload" className="bg-blue-500 text-white px-3 py-1 rounded mt-2 inline-block cursor-pointer hover:bg-blue-600 text-xs">
                    Choose File
                  </label>
                </div>
              </div>

              <div className="mb-6 bg-white p-4 rounded-lg shadow-md">
                <h3 className="text-lg font-semibold mb-3 text-gray-800">Bulk Receipt Upload (PDF)</h3>
                <div className="mb-4">
                  <input
                    type="text"
                    id="pdf-payer-name"
                    placeholder="Enter payer name to match PDF receipt"
                    className="p-2 border border-gray-200 rounded w-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs"
                  />
                </div>
                <div
                  onDrop={(e) => {
                    const payerName = document.getElementById("pdf-payer-name").value;
                    if (payerName) {
                      handlePDFDrop(e, payerName);
                    } else {
                      setError("Please enter payer name before dropping PDF.");
                    }
                  }}
                  onDragOver={handlePDFDragOver}
                  onDragLeave={handlePDFDragLeave}
                  className="border-2 border-dashed border-gray-300 rounded-md p-4 text-center cursor-pointer hover:border-blue-500 transition-colors text-xs"
                >
                  <p>Drag and drop PDF receipt here, or click to select file.</p>
                  <input
                    type="file"
                    accept=".pdf"
                    onChange={(e) => {
                      const payerName = document.getElementById("pdf-payer-name").value;
                      if (payerName) {
                        handlePDFUpload(e, payerName);
                      } else {
                        setError("Please enter payer name before selecting PDF.");
                      }
                    }}
                    className="hidden"
                    id="pdf-upload"
                  />
                  <label htmlFor="pdf-upload" className="bg-blue-500 text-white px-3 py-1 rounded mt-2 inline-block cursor-pointer hover:bg-blue-600 text-xs">
                    Choose File
                  </label>
                </div>
                {pdfError && <p className="text-red-500 mt-2 text-xs">{pdfError}</p>}
              </div>

              <div className="mb-4 flex gap-2">
                <input
                  type="text"
                  placeholder="Search payers..."
                  value={searchTerm}
                  onChange={(e) => filterPayers(e.target.value)}
                  className="p-2 border border-gray-200 rounded flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs"
                />
                <select
                  value={filterConfig}
                  onChange={(e) => setFilterConfig(e.target.value)}
                  className="p-2 border border-gray-200 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs"
                >
                  <option value="all">All Statuses</option>
                  <option value="paid">Paid</option>
                  <option value="not paid">Not Paid</option>
                </select>
              </div>

              <div className="overflow-x-auto">
                <table className="w-full border-collapse">
                  <thead>
                    <tr className="bg-gray-100">
                      <th className="border-b border-gray-200 p-2 text-left text-gray-700 font-semibold text-xs">
                        <button onClick={() => sortPayers('name')} className="text-left">
                          Name {sortConfig.key === 'name' && (sortConfig.direction === 'ascending' ? '▲' : '▼')}
                        </button>
                      </th>
                      <th className="border-b border-gray-200 p-2 text-left text-gray-700 font-semibold text-xs">
                        <button onClick={() => sortPayers('expectedAmount')} className="text-left">
                          Expected Amount (RM) {sortConfig.key === 'expectedAmount' && (sortConfig.direction === 'ascending' ? '▲' : '▼')}
                        </button>
                      </th>
                      <th className="border-b border-gray-200 p-2 text-left text-gray-700 font-semibold text-xs">Paid Amount (RM)</th>
                      <th className="border-b border-gray-200 p-2 text-left text-gray-700 font-semibold text-xs">Transaction Date</th>
                      <th className="border-b border-gray-200 p-2 text-left text-gray-700 font-semibold text-xs">
                        <button onClick={() => sortPayers('status')} className="text-left">
                          Status {sortConfig.key === 'status' && (sortConfig.direction === 'ascending' ? '▲' : '▼')}
                        </button>
                      </th>
                      <th className="border-b border-gray-200 p-2 text-left text-gray-700 font-semibold text-xs">Receipt</th>
                      <th className="border-b border-gray-200 p-2 text-left text-gray-700 font-semibold text-xs">Actions</th>
                      <th className="border-b border-gray-200 p-2 text-left text-gray-700 font-semibold text-xs">
                        <input
                          type="checkbox"
                          checked={selectedPayers.length === sortedAndFilteredPayers().length}
                          onChange={toggleSelectAllPayers}
                          className="mr-2"
                        />
                        Select
                      </th>
                    </tr>
                  </thead>
                  <tbody>
                    {sortedAndFilteredPayers().map(payer => (
                      <tr key={payer.id} className="hover:bg-gray-50">
                        <td className="border-b border-gray-200 p-2 text-gray-700 text-xs">{payer.name}</td>
                        <td className="border-b border-gray-200 p-2 text-gray-700 text-xs">{payer.expectedAmount}</td>
                        <td className="border-b border-gray-200 p-2 text-gray-700 text-xs">{payer.paidAmount ? payer.paidAmount : "-"}</td>
                        <td className="border-b border-gray-200 p-2 text-gray-700 text-xs">{payer.transactionDate ? payer.transactionDate : "-"}</td>
                        <td className="border-b border-gray-200 p-2 text-gray-700 text-xs">{payer.status}</td>
                        <td className="border-b border-gray-200 p-2">
                          {payer.pdfFilename ? (
                            <a
                              href={`#`}
                              onClick={() => {
                                const invalidReceipt = invalidReceipts.find(r => r.filename === payer.pdfFilename);
                                if (invalidReceipt && invalidReceipt.pngData) {
                                  openModal(invalidReceipt.pngData);
                                } else {
                                  setError("No receipt image available.");
                                }
                              }}
                              className="text-blue-600 hover:text-blue-800 underline text-xs"
                            >
                              View Receipt
                            </a>
                          ) : (
                            <span className="text-gray-400 text-xs">No Receipt</span>
                          )}
                        </td>
                        <td className="border-b border-gray-200 p-2 flex gap-1">
                          <button
                            onClick={() => {
                              const newPaidAmount = prompt("Enter paid amount:", payer.paidAmount || "");
                              if (newPaidAmount !== null) {
                                const parsedAmount = parseFloat(newPaidAmount);
                                if (!isNaN(parsedAmount)) {
                                  const newTransactionDate = prompt("Enter transaction date (optional):", payer.transactionDate || "");
                                  const newStatus = newPaidAmount > 0 ? "Paid" : "Not Paid";
                                  editPayer(payer.id, {
                                    ...payer,
                                    paidAmount: parsedAmount,
                                    transactionDate: newTransactionDate,
                                    status: newStatus
                                  });
                                } else {
                                  setError("Invalid amount entered.");
                                }
                              }
                            }}
                            className="bg-yellow-500 text-white px-1 py-1 rounded shadow-sm hover:bg-yellow-600 hover:shadow-md transition-all duration-300 text-xs"
                          >
                            Edit
                          </button>
                          <button
                            onClick={() => deletePayer(payer.id)}
                            className="bg-red-500 text-white px-1 py-1 rounded shadow-sm hover:bg-red-600 hover:shadow-md transition-all duration-300 text-xs"
                          >
                            Delete
                          </button>
                        </td>
                        <td className="border-b border-gray-200 p-2">
                          <input
                            type="checkbox"
                            checked={selectedPayers.includes(payer.id)}
                            onChange={() => togglePayerSelection(payer.id)}
                            className="text-xs"
                          />
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <button
                onClick={() => handlePrintButtonClick(selectedPayers)}
                className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mt-4 text-sm"
                disabled={selectedPayers.length === 0}
              >
                Print {selectedPayers.length > 0 && `(${selectedPayers.length})`}
              </button>
              <PrintPreviewModal
                isOpen={isPrintPreviewOpen}
                onClose={() => setIsPrintPreviewOpen(false)}
                pdfDataUrl={pdfDataUrl}
                orientation={printOrientation}
                setOrientation={setPrintOrientation}
                colorMode={printColorMode}
                setColorMode={setColorMode}
                zoom={printZoom}
                setZoom={setPrintZoom}
                printDocument={handlePrint}
              />
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById("root"));
