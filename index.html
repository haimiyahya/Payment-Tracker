<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                var filteredData = jsonData.filter(row => row.some(filledCell));
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Payment Tracker</title>
  <link rel="icon" type="image/jpeg" href="Payment-Tracker.jpg" />
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.5/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="text-xs">
  <div id="root"></div>
  <script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
      return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
      if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
        try {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row => row.some(filledCell));
          var headerRowIndex = filteredData.findIndex((row, index) =>
            row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
          );
          if (headerRowIndex === -1 || headerRowIndex > 25) {
            headerRowIndex = 0;
          }
          var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
          csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
          return csv;
        } catch (e) {
          console.error(e);
          return "";
        }
      }
      return gk_fileData[filename] || "";
    }
  </script>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const db = new Dexie("PaymentTrackerDB");
    db.version(6).stores({
      payers: "++id,name,expectedAmount,paidAmount,transactionDate,status,pdfFilename,sessionId",
      invalidReceipts: "++id,filename,reason,data,pngData,sessionId",
      settings: "key,value",
      paymentSessions: "++id,name",
      deletedSessions: "++id,name,payers,invalidReceipts"
    });

    const BM25 = {
      k1: 1.5,
      b: 0.75,
      threshold: 0.8,
      tokenize: (text) => text.toLowerCase().split(/\W+/).filter(t => t.length >= 2),
      computeScore: (query, doc, docLength, avgDocLength, idf) => {
        let score = 0;
        query.forEach(term => {
          const freq = doc.filter(t => t === term).length;
          const numerator = freq * (BM25.k1 + 1);
          const denominator = freq + BM25.k1 * (1 - BM25.b + BM25.b * (docLength / avgDocLength));
          score += idf[term] * numerator / denominator;
        });
        return score;
      },
      match: (query, documents) => {
        console.log(`BM25.match: Query=${query}, Documents=${JSON.stringify(documents.map(d => ({ id: d.id, name: d.name })))}`);
        const tokens = BM25.tokenize(query);
        console.log(`BM25.match: Query tokens=${tokens}`);
        const docTokens = documents.map(doc => ({
          id: doc.id,
          name: doc.name,
          tokens: BM25.tokenize(doc.name)
        }));
        console.log(`BM25.match: Doc tokens=${JSON.stringify(docTokens.map(dt => ({ id: dt.id, name: dt.name, tokens: dt.tokens })))}`);
        const docLengths = docTokens.map(dt => dt.tokens.length);
        const avgDocLength = docLengths.reduce((a, b) => a + b, 0) / docLengths.length || 1;
        const idf = {};
        tokens.forEach(term => {
          const docsWithTerm = docTokens.filter(dt => dt.tokens.includes(term)).length;
          idf[term] = Math.log((documents.length - docsWithTerm + 0.5) / (docsWithTerm + 0.5) + 1);
        });
        const scores = docTokens.map(dt => ({
          id: dt.id,
          name: dt.name,
          score: BM25.computeScore(tokens, dt.tokens, dt.tokens.length, avgDocLength, idf)
        }));
        console.log(`BM25.match: Scores=${JSON.stringify(scores)}`);
        const sorted = scores.sort((a, b) => b.score - a.score);
        if (sorted[0] && sorted[0].score > BM25.threshold) {
          const topScore = sorted[0].score;
          const closeScores = sorted.filter(s => s.score >= topScore * 0.9);
          if (closeScores.length === 1) {
            console.log(`BM25.match: Returning match=${JSON.stringify(sorted[0])}`);
            return sorted[0];
          }
        }
        console.log(`BM25.match: No match found`);
        return null;
      }
    };

    const formatPDFText = (text) => {
      if (!text || typeof text !== "string") return "No text available";
      let cleaned = text.replace(/[\x00-\x1F\x7F]+/g, " ");
      cleaned = cleaned.replace(/\s+/g, " ").trim();
      const amountRegex = /\RM?\d+\.\d{2}\b|\d+\s*RM\b/i;
      const dateRegex = /\b(\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\s+\d{2}:\d{2}:\d{2}|\d{1,2}[/-]\d{1,2}[/-]\d{2,4}(?:\s+\d{2}:\d{2}:\d{2})?|\d{4}[/-]\d{1,2}[/-]\d{1,2}(?:\s+\d{2}:\d{2}:\d{2})?)\b/i;
      const refNumberRegex = /\b\d{10}\b/;
      const otherDetailsRegex = /\bYURAN\s+(?:JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\s+\d{4}\b/;
      const amountMatch = cleaned.match(amountRegex);
      const dateMatch = cleaned.match(dateRegex);
      const refNumberMatch = cleaned.match(refNumberRegex);
      const otherDetailsMatch = cleaned.match(otherDetailsRegex);
      let prioritizedText = "";
      if (dateMatch) prioritizedText += `Date: ${dateMatch[0]}\n`;
      if (amountMatch) prioritizedText += `Amount: ${amountMatch[0]}\n`;
      if (refNumberMatch) prioritizedText += `Reference Number: ${refNumberMatch[0]}\n`;
      if (otherDetailsMatch) prioritizedText += `Other Transfer Details: ${otherDetailsMatch[0]}\n`;
      let remainingText = cleaned;
      if (amountMatch) remainingText = remainingText.replace(amountMatch[0], "").replace(/\s+/g, " ").trim();
      if (dateMatch) remainingText = remainingText.replace(dateMatch[0], "").replace(/\s+/g, " ").trim();
      if (refNumberMatch) remainingText = remainingText.replace(refNumberMatch[0], "").replace(/\s+/g, " ").trim();
      if (otherDetailsMatch) remainingText = remainingText.replace(otherDetailsMatch[0], "").replace(/\s+/g, " ").trim();
      prioritizedText += remainingText;
      if (prioritizedText.length > 500) {
        prioritizedText = prioritizedText.substring(0, 500) + "...";
      }
      return prioritizedText || "No text available";
    };

    const convertPDFToPNG = async (file) => {
      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({ scale: 1.0 });
        const scale = 400 / viewport.width;
        const scaledViewport = page.getViewport({ scale });
        const canvas = document.createElement("canvas");
        canvas.width = scaledViewport.width;
        canvas.height = scaledViewport.height;
        const context = canvas.getContext("2d");
        await page.render({
          canvasContext: context,
          viewport: scaledViewport
        }).promise;
        const pngData = canvas.toDataURL("image/png");
        return pngData;
      } catch (err) {
        console.error(`Error converting PDF ${file.name} to PNG:`, err);
        return null;
      }
    };

    function ImageModal({ isOpen, onClose, imageSrc }) {
      if (!isOpen || !imageSrc) return null;
      return (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
          onClick={onClose}
        >
          <div 
            className="bg-white p-2 rounded-lg shadow-xl max-w-2xl w-full relative"
            onClick={e => e.stopPropagation()}
          >
            <button
              onClick={onClose}
              className="absolute top-1 right-1 text-gray-600 hover:text-gray-800 text-sm"
            >
              ×
            </button>
            <h3 className="text-xs font-semibold text-gray-800 mb-1">Receipt Preview</h3>
            <img 
              src={imageSrc} 
              alt="Receipt Preview" 
              className="max-w-[300px] h-auto rounded shadow-sm"
            />
          </div>
        </div>
      );
    }

    function PrintPreviewModal({ isOpen, onClose, onPrint, pdfDataUrl, setOrientation, setZoom }) {
      if (!isOpen) return null;
      return (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
          onClick={onClose}
        >
          <div 
            className="bg-white p-3 rounded-lg shadow-xl max-w-4xl w-full relative"
            onClick={e => e.stopPropagation()}
          >
            <button
              onClick={onClose}
              className="absolute top-1 right-1 text-gray-600 hover:text-gray-800 text-sm"
            >
              ×
            </button>
            <h3 className="text-base font-semibold text-gray-800 mb-2">Print Preview</h3>
            <div className="flex flex-col sm:flex-row gap-2 mb-2">
              <select
                onChange={(e) => setOrientation(e.target.value)}
                className="p-1 border border-gray-200 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs"
              >
                <option value="portrait">Portrait</option>
                <option value="landscape">Landscape</option>
              </select>
              <select
                onChange={(e) => setZoom(parseFloat(e.target.value))}
                className="p-1 border border-gray-200 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs"
              >
                <option value="1.0">100%</option>
                <option value="0.9">90%</option>
                <option value="0.8">80%</option>
                <option value="0.7">70%</option>
                <option value="0.6">60%</option>
                <option value="0.5">50%</option>
              </select>
              <button
                onClick={onPrint}
                className="bg-blue-600 text-white px-2 py-1 rounded shadow-md hover:bg-blue-700 hover:shadow-lg transition-all duration-300 text-xs"
              >
                Print/Download
              </button>
            </div>
            <iframe
              src={pdfDataUrl}
              className="w-full h-[500px] border border-gray-200 rounded"
              title="PDF Preview"
            ></iframe>
          </div>
        </div>
      );
    }

    function SessionsModal({ isOpen, onClose, sessions, deletedSessions, currentSession, setSessions, setDeletedSessions, setCurrentSession, setPayers, setInvalidReceipts, setError, setIsLoading, newSessionName, setNewSessionName, openSession, createNewSession, deleteSession, restoreSession, permanentlyDeleteSession, clearTrashBin }) {
      if (!isOpen) return null;
      const mustCreateSession = sessions.length === 0 && !currentSession;
      return (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
          onClick={mustCreateSession ? null : onClose}
        >
          <div 
            className="bg-white p-3 rounded-lg shadow-xl max-w-lg w-full relative"
            onClick={e => e.stopPropagation()}
          >
            <button
              onClick={onClose}
              className={`absolute top-1 right-1 text-gray-600 hover:text-gray-800 text-sm ${mustCreateSession ? 'opacity-50 cursor-not-allowed' : ''}`}
              disabled={mustCreateSession}
            >
              ×
            </button>
            <h2 className="text-base font-semibold text-gray-800 mb-2">Payment Sessions</h2>
            {mustCreateSession && (
              <p className="text-red-500 mb-2 text-xs">Please create a session to continue.</p>
            )}
            <div className="flex flex-col sm:flex-row gap-1 mb-2">
              <input
                type="text"
                value={newSessionName}
                onChange={(e) => setNewSessionName(e.target.value)}
                placeholder="New Session Name (e.g., Book Payments)"
                className="p-1 border border-gray-200 rounded flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs"
              />
              <button
                onClick={createNewSession}
                className="bg-blue-600 text-white px-2 py-1 rounded shadow-md hover:bg-blue-700 hover:shadow-lg transition-all duration-300 text-xs"
              >
                New Session
              </button>
              <select
                onChange={(e) => openSession(e.target.value)}
                className="p-1 border border-gray-200 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs"
                value={currentSession ? currentSession.id : ""}
              >
                {sessions.length === 0 && (
                  <option value="">Select a Session</option>
                )}
                {sessions.map(session => (
                  <option key={session.id} value={session.id}>{session.name}</option>
                ))}
              </select>
              {currentSession && (
                <button
                  onClick={deleteSession}
                  className="bg-red-500 text-white px-2 py-1 rounded shadow-md hover:bg-red-600 hover:shadow-lg transition-all duration-300 text-xs"
                >
                  Delete Session
                </button>
              )}
            </div>
            {deletedSessions.length > 0 && (
              <div id="trash-bin" className="bg-gray-50 p-3 rounded-lg shadow-sm">
                <div className="flex justify-between items-center mb-2">
                  <h2 className="text-base font-semibold text-gray-800">Trash Bin</h2>
                  <button
                    onClick={clearTrashBin}
                    className="bg-red-600 text-white px-2 py-1 rounded shadow-md hover:bg-red-600 hover:shadow-lg transition-all duration-300 text-xs"
                  >
                    Clear Trash Bin
                  </button>
                </div>
                <div className="overflow-x-auto">
                  <table className="w-full border-collapse">
                    <thead>
                      <tr className="bg-gray-100">
                        <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Session Name</th>
                        <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Actions</th>
                      </tr>
                    </thead>
                    <tbody>
                      {deletedSessions.map(session => (
                        <tr key={session.id} className="hover:bg-gray-50">
                          <td className="border-b border-gray-200 p-1 text-gray-700 text-xs">{session.name}</td>
                          <td className="border-b border-gray-200 p-1 flex gap-1">
                            <button
                              onClick={() => restoreSession(session.id)}
                              className="bg-green-600 text-white px-1 py-1 rounded shadow-sm hover:bg-green-700 hover:shadow-md transition-all duration-300 text-xs"
                            >
                              Restore
                            </button>
                            <button
                              onClick={() => permanentlyDeleteSession(session.id)}
                              className="bg-red-500 text-white px-1 py-1 rounded shadow-sm hover:bg-red-600 hover:shadow-md transition-all duration-300 text-xs"
                            >
                              Permanently Delete
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    function NavBar({ isAuthenticated, currentSession, handleLogout, scrollToSection, openSessionsModal }) {
      const [isOpen, setIsOpen] = useState(false);
      const navItems = [
        { name: "Home", section: "dashboard" },
        { name: "Sessions", action: openSessionsModal },
        { name: "Logout", action: handleLogout },
      ];
      return (
        <nav className="bg-blue-600 text-white fixed top-0 left-0 w-full z-40 shadow-md">
          <div className="max-w-5xl mx-auto px-2">
            <div className="flex justify-between items-center h-10">
              <div className="flex-shrink-0">
                <h1 className="text-base font-bold">Payment Tracker</h1>
              </div>
              <div className="hidden sm:flex sm:space-x-1">
                {isAuthenticated && navItems.map((item) => (
                  item.action ? (
                    <button
                      key={item.name}
                      onClick={item.action}
                      className="px-1 py-1 rounded text-xs font-medium hover:bg-blue-700 transition-colors"
                    >
                      {item.name}
                    </button>
                  ) : (
                    <button
                      key={item.name}
                      onClick={() => scrollToSection(item.section)}
                      className="px-1 py-1 rounded text-xs font-medium hover:bg-blue-700 transition-colors"
                    >
                      {item.name}
                    </button>
                  )
                ))}
              </div>
              <div className="sm:hidden">
                <button
                  onClick={() => setIsOpen(!isOpen)}
                  className="text-white hover:bg-blue-700 p-1 rounded focus:outline-none"
                >
                  <svg
                    className="h-4 w-4"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d={isOpen ? "M6 18L18 6M6 6l12 12" : "M4 6h16M4 12h16m-7 6h7"}
                    />
                  </svg>
                </button>
              </div>
            </div>
            {isOpen && (
              <div className="sm:hidden">
                <div className="px-2 pt-1 pb-2 space-y-1">
                  {isAuthenticated && navItems.map((item) => (
                    item.action ? (
                      <button
                        key={item.name}
                        onClick={() => { item.action(); setIsOpen(false); }}
                        className="block px-1 py-1 rounded text-xs font-medium hover:bg-blue-700 w-full text-left"
                      >
                        {item.name}
                      </button>
                    ) : (
                      <button
                        key={item.name}
                        onClick={() => { scrollToSection(item.section); setIsOpen(false); }}
                        className="block px-1 py-1 rounded text-xs font-medium hover:bg-blue-700 w-full text-left"
                      >
                        {item.name}
                      </button>
                    )
                  ))}
                </div>
              </div>
            )}
          </div>
        </nav>
      );
    }

    function App() {
      const [isAuthenticated, setIsAuthenticated] = useState(false);
      const [password, setPassword] = useState("");
      const [error, setError] = useState("");
      const [pdfError, setPdfError] = useState("");
      const [payers, setPayers] = useState([]);
      const [invalidReceipts, setInvalidReceipts] = useState([]);
      const [newPayer, setNewPayer] = useState({ name: "", expectedAmount: "" });
      const [filter, setFilter] = useState("All");
      const [sortBy, setSortBy] = useState("name-asc");
      const [sessionTimeout, setSessionTimeout] = useState(null);
      const [isDragging, setIsDragging] = useState(false);
      const [isDraggingCSV, setIsDraggingCSV] = useState(false);
      const [sessions, setSessions] = useState([]);
      const [currentSession, setCurrentSession] = useState(null);
      const [newSessionName, setNewSessionName] = useState("");
      const [isLoading, setIsLoading] = useState(false);
      const [deletedSessions, setDeletedSessions] = useState([]);
      const [isModalOpen, setIsModalOpen] = useState(false);
      const [selectedImage, setSelectedImage] = useState(null);
      const [isSessionsModalOpen, setIsSessionsModalOpen] = useState(false);
      const [isPrintPreviewOpen, setIsPrintPreviewOpen] = useState(false);
      const [pdfDataUrl, setPdfDataUrl] = useState("");
      const [orientation, setOrientation] = useState("portrait");
      const [zoom, setZoom] = useState(1.0);
      const [validateReceiptDate, setValidateReceiptDate] = useState(false);
      const [requiredReceiptDate, setRequiredReceiptDate] = useState("");

      const openModal = (imageSrc) => {
        setSelectedImage(imageSrc);
        setIsModalOpen(true);
      };
      const closeModal = () => {
        setIsModalOpen(false);
        setSelectedImage(null);
      };
      const openSessionsModal = () => setIsSessionsModalOpen(true);
      const closeSessionsModal = () => {
        if (sessions.length === 0 && !currentSession) return;
        setIsSessionsModalOpen(false);
      };

      const loadData = async () => {
        const sessionsData = await db.paymentSessions.toArray();
        setSessions(sessionsData);
        const deletedSessionsData = await db.deletedSessions.toArray();
        setDeletedSessions(deletedSessionsData);
        if (sessionsData.length > 0) {
          const lastSession = sessionsData[sessionsData.length - 1];
          setCurrentSession(lastSession);
          const payersData = await db.payers.where("sessionId").equals(lastSession.id).toArray();
          const invalidData = await db.invalidReceipts.where("sessionId").equals(lastSession.id).toArray();
          setPayers(payersData.map(p => ({
            ...p,
            status: p.status || (p.paidAmount ? (p.paidAmount === p.expectedAmount ? "Paid" : "Incorrect") : "No File Matched"),
            pdfFilename: p.pdfFilename || null,
            transactionDate: p.transactionDate || null
          })));
          setInvalidReceipts(invalidData);
        } else {
          setIsSessionsModalOpen(true);
        }
      };

      const scrollToSection = (sectionId) => {
        const element = document.getElementById(sectionId);
        if (element) {
          const navHeight = 40;
          const elementPosition = element.getBoundingClientRect().top + window.scrollY;
          window.scrollTo({ top: elementPosition - navHeight, behavior: "smooth" });
        }
      };

      useEffect(() => {
        const checkSession = async () => {
          const session = await db.settings.get("session");
          if (session && session.value > Date.now()) {
            setIsAuthenticated(true);
            await loadData();
            resetSessionTimeout();
          } else {
            setIsAuthenticated(false);
          }
        };
        checkSession();
        return () => clearTimeout(sessionTimeout);
      }, []);

      const resetSessionTimeout = () => {
        clearTimeout(sessionTimeout);
        const timeout = setTimeout(async () => {
          setIsAuthenticated(false);
          await db.settings.delete("session");
          setError("Session timed out. Please log in again.");
          setPayers([]); setInvalidReceipts([]); setSessions([]); setDeletedSessions([]); setCurrentSession(null);
          setIsSessionsModalOpen(true);
        }, 30 * 60 * 1000);
        setSessionTimeout(timeout);
      };

      const handleLogin = async (e) => {
        e.preventDefault();
        setError("");
        const storedKey = await db.settings.get("passwordKey");
        const derivedKey = CryptoJS.PBKDF2(password, "salt", { keySize: 256/32, iterations: 150000 }).toString();
        if (!storedKey) {
          await db.settings.put({ key: "passwordKey", value: derivedKey });
          await db.settings.put({ key: "session", value: Date.now() + 30 * 60 * 1000 });
          setIsAuthenticated(true); await loadData(); resetSessionTimeout(); setPassword("");
        } else if (storedKey.value === derivedKey) {
          await db.settings.put({ key: "session", value: Date.now() + 30 * 60 * 1000 });
          setIsAuthenticated(true); await loadData(); resetSessionTimeout(); setPassword("");
        } else {
          setError("Incorrect password");
        }
      };

      const handleLogout = async () => {
        await db.settings.delete("session");
        clearTimeout(sessionTimeout);
        setIsAuthenticated(false); setError(""); setPdfError("");
        setPayers([]); setInvalidReceipts([]); setSessions([]); setDeletedSessions([]); setCurrentSession(null);
        setIsSessionsModalOpen(true);
      };

      const createNewSession = async () => {
        if (!newSessionName.trim()) { setError("Please enter a session name"); return; }
        const sessionNameLower = newSessionName.trim().toLowerCase();
        if (sessions.find(s => s.name.toLowerCase() === sessionNameLower)) {
          setError("A session with this name already exists. Please choose a different name."); return;
        }
        setIsLoading(true); setError("");
        setTimeout(async () => {
          const session = { name: newSessionName.trim() };
          const sessionId = await db.paymentSessions.add(session);
          const newSessionWithId = { ...session, id: sessionId };
          setSessions(prev => [...prev, newSessionWithId]); setCurrentSession(newSessionWithId);
          setPayers([]); setInvalidReceipts([]); setNewSessionName("");
          setIsSessionsModalOpen(false); setIsLoading(false);
        }, 500);
      };

      const openSession = async (sessionId) => {
        if (!sessionId) { setCurrentSession(null); setPayers([]); setInvalidReceipts([]); setError(""); setPdfError(""); setIsLoading(false); return; }
        const session = sessions.find(s => s.id === parseInt(sessionId));
        if (!session) { setError("Session not found"); return; }
        setIsLoading(true);
        setTimeout(async () => {
          setCurrentSession(session);
          const payersData = await db.payers.where("sessionId").equals(session.id).toArray();
          const invalidData = await db.invalidReceipts.where("sessionId").equals(session.id).toArray();
          setPayers(payersData.map(p => ({ ...p, status: p.status || (p.paidAmount ? (p.paidAmount === p.expectedAmount ? "Paid" : "Incorrect") : "No File Matched"), pdfFilename: p.pdfFilename || null, transactionDate: p.transactionDate || null })));
          setInvalidReceipts(invalidData);
          setError(""); setPdfError(""); setIsLoading(false);
        }, 500);
      };

      const deleteSession = async () => {
        if (!currentSession) { setError("No session selected to delete"); return; }
        setIsLoading(true);
        setTimeout(async () => {
          const sessionId = currentSession.id;
          const sessionPayers = await db.payers.where("sessionId").equals(sessionId).toArray();
          const sessionInvalidReceipts = await db.invalidReceipts.where("sessionId").equals(sessionId).toArray();
          await db.deletedSessions.add({ id: sessionId, name: currentSession.name, payers: sessionPayers, invalidReceipts: sessionInvalidReceipts });
          await db.paymentSessions.delete(sessionId);
          await db.payers.where("sessionId").equals(sessionId).delete();
          await db.invalidReceipts.where("sessionId").equals(sessionId).delete();
          setDeletedSessions(prev => [...prev, { id: sessionId, name: currentSession.name, payers: sessionPayers, invalidReceipts: sessionInvalidReceipts }]);
          const updatedSessions = sessions.filter(s => s.id !== sessionId);
          setSessions(updatedSessions);
          let nextSession = updatedSessions.length > 0 ? updatedSessions[updatedSessions.length - 1] : null;
          setCurrentSession(null); setPayers([]); setInvalidReceipts([]);
          if (nextSession) { await openSession(nextSession.id); } else { setIsSessionsModalOpen(true); }
          setError("Session moved to Trash Bin"); setIsLoading(false);
        }, 500);
      };

      const restoreSession = async (sessionId) => {
        setIsLoading(true);
        setTimeout(async () => {
          const deletedSession = deletedSessions.find(s => s.id === sessionId);
          if (!deletedSession) { setError("Session not found in Trash Bin"); setIsLoading(false); return; }
          await db.paymentSessions.add({ id: sessionId, name: deletedSession.name });
          const payersToRestore = deletedSession.payers.map(p => ({ ...p, sessionId }));
          const invalidReceiptsToRestore = deletedSession.invalidReceipts.map(r => ({ ...r, sessionId }));
          if (payersToRestore.length > 0) await db.payers.bulkAdd(payersToRestore);
          if (invalidReceiptsToRestore.length > 0) await db.invalidReceipts.bulkAdd(invalidReceiptsToRestore);
          await db.deletedSessions.delete(sessionId);
          setSessions(prev => [...prev, { id: sessionId, name: deletedSession.name }]);
          setDeletedSessions(prev => prev.filter(s => s.id !== sessionId));
          setCurrentSession({ id: sessionId, name: deletedSession.name });
          setPayers(payersToRestore.map(p => ({ ...p, status: p.status || (p.paidAmount ? (p.paidAmount === p.expectedAmount ? "Paid" : "Incorrect") : "No File Matched"), pdfFilename: p.pdfFilename || null, transactionDate: p.transactionDate || null })));
          setInvalidReceipts(invalidReceiptsToRestore);
          setError("Session restored successfully"); setIsLoading(false);
        }, 500);
      };

      const permanentlyDeleteSession = async (sessionId) => {
        setIsLoading(true);
        setTimeout(async () => {
          await db.deletedSessions.delete(sessionId);
          setDeletedSessions(prev => prev.filter(s => s.id !== sessionId));
          setError("Session permanently deleted"); setIsLoading(false);
        }, 500);
      };

      const clearTrashBin = async () => {
        setIsLoading(true);
        setTimeout(async () => {
          await db.deletedSessions.clear(); setDeletedSessions([]);
          setError("Trash Bin cleared"); setIsLoading(false);
        }, 500);
      };

      const addPayer = async (e) => {
        e.preventDefault();
        if (!currentSession) { setError("Please create or select a session first"); return; }
        const { name, expectedAmount } = newPayer;
        if (!name.trim() || isNaN(expectedAmount) || expectedAmount <= 0) { setError("Invalid name or amount"); return; }
        const payer = { name: name.trim(), expectedAmount: parseFloat(expectedAmount).toFixed(2), paidAmount: null, transactionDate: null, status: "No File Matched", pdfFilename: null, sessionId: currentSession.id };
        const id = await db.payers.add(payer);
        setPayers(prev => [...prev, { ...payer, id }]);
        setNewPayer({ name: "", expectedAmount: "" });
      };

      const processCSV = async (file) => {
        console.log(`Processing CSV: ${file.name}`);
        try {
          const text = await file.text();
          Papa.parse(text, {
            header: true, skipEmptyLines: true,
            complete: async (result) => {
              const data = result.data; const errors = []; const validPayers = [];
              const headers = result.meta.fields.map(h => h.replace(/[\uFEFF"']+/g, '').trim().toLowerCase());
              const nameHeader = headers.find(h => h === "name");
              const amountHeader = headers.find(h => h === "expected amount");
              if (!nameHeader || !amountHeader) { setError("CSV must have 'Name' and 'Expected Amount' columns (case-insensitive)"); return; }
              const originalNameHeader = result.meta.fields[headers.indexOf("name")];
              const originalAmountHeader = result.meta.fields[headers.indexOf("expected amount")];
              for (let i = 0; i < data.length; i++) {
                const row = data[i];
                const name = row[originalNameHeader]?.trim();
                const expectedAmount = parseFloat(row[originalAmountHeader]);
                if (!name || isNaN(expectedAmount) || expectedAmount <= 0) { errors.push(`Row ${i + 2}: Invalid name or amount`); continue; }
                validPayers.push({ name, expectedAmount: expectedAmount.toFixed(2), paidAmount: null, transactionDate: null, status: "No File Matched", pdfFilename: null, sessionId: currentSession.id });
              }
              if (validPayers.length > 0) {
                const ids = await db.payers.bulkAdd(validPayers, { allKeys: true });
                const newPayersData = validPayers.map((p, index) => ({ ...p, id: ids[index] }));
                setPayers(prev => [...prev, ...newPayersData]);
              }
              if (errors.length > 0) { setError(`Added ${validPayers.length} payers. Errors: ${errors.join("; ")}`); } 
              else { setError(`Successfully added ${validPayers.length} payers`); }
            },
            error: (err) => { console.error(`Error parsing CSV ${file.name}:`, err); setError(`Failed to parse CSV: ${err.message}`); }
          });
        } catch (err) { console.error(`Error processing CSV ${file.name}:`, err); setError(`Failed to process CSV: ${err.message}`); }
      };

      const handleCSVUpload = async (files) => {
        if (!currentSession) { setError("Please create or select a session first"); return; }
        const csvFiles = Array.from(files).filter(f => f.type === "text/csv" || f.name.endsWith(".csv"));
        if (csvFiles.length === 0) { setError("Please upload a valid CSV file"); return; }
        setError("");
        for (const file of csvFiles) { await processCSV(file); }
      };

      const handleCSVDragOver = (e) => { e.preventDefault(); setIsDraggingCSV(true); };
      const handleCSVDragLeave = (e) => { e.preventDefault(); setIsDraggingCSV(false); };
      const handleCSVDrop = (e) => { e.preventDefault(); setIsDraggingCSV(false); handleCSVUpload(e.dataTransfer.files); };

      const editPayer = async (id, updatedPayer) => {
        if (!updatedPayer.name.trim() || isNaN(updatedPayer.expectedAmount) || updatedPayer.expectedAmount <= 0) { setError("Invalid name or amount"); return; }
        updatedPayer.expectedAmount = parseFloat(updatedPayer.expectedAmount).toFixed(2);
        await db.payers.update(id, updatedPayer);
        setPayers(prev => prev.map(p => (p.id === id ? { ...p, ...updatedPayer } : p)));
      };

      const deletePayer = async (id) => {
        await db.payers.delete(id);
        setPayers(prev => prev.filter(p => p.id !== id));
      };

      const validatePDFFile = async (file) => {
        try {
          const arrayBuffer = await file.slice(0, 5).arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);
          const magicNumber = String.fromCharCode(...uint8Array);
          return magicNumber === "%PDF-";
        } catch (err) { console.error(`Error validating PDF ${file.name}:`, err); return false; }
      };

      // Renamed from processPDF and now accepts state as parameters
      const processPDFLogic = async (file, currentValidateDateFlag, currentRequiredDateValue) => {
        if (!currentSession) {
          setError("Please create or select a session first");
          return;
        }
        console.log(`[processPDFLogic ENTRY] File: ${file.name}, Validate Flag: ${currentValidateDateFlag}, Required Date: ${currentRequiredDateValue}`);

        let text = "";
        let pngData = null;
        try {
          const isValidPDF = await validatePDFFile(file);
          if (!isValidPDF) {
            throw new Error("Invalid PDF format: File does not start with %PDF-");
          }
          const arrayBuffer = await file.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
          for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const content = await page.getTextContent();
            text += content.items.map(item => item.str).join(" ") + " ";
          }
          console.log(`Extracted text from ${file.name}: ${text.slice(0, 100)}...`);

          // --- START: Modified Date Validation Logic ---
          if (currentValidateDateFlag && currentRequiredDateValue) {
            const dateRegexForValidation = /\b(\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}(?:\s+\d{2}:\d{2}:\d{2})?|\d{1,2}[./-]\d{1,2}[./-]\d{2,4}(?:\s+\d{2}:\d{2}:\d{2})?|\d{4}[./-]\d{1,2}[./-]\d{1,2}(?:\s+\d{2}:\d{2}:\d{2})?)\b/i;
            const pdfDateMatch = text.match(dateRegexForValidation);

            if (pdfDateMatch && pdfDateMatch[0]) {
              let pdfDateString = pdfDateMatch[0];
              pdfDateString = pdfDateString.replace(/\s+\d{2}:\d{2}:\d{2}$/, '').trim();
              
              let pdfDate;
              pdfDate = new Date(pdfDateString); // Initial attempt

              if (isNaN(pdfDate.getTime()) || pdfDate.getFullYear() < 1970 || pdfDate.getFullYear() > 2100) { // Basic sanity check for year
                  // More robust parsing for common variants if initial parse fails
                  const parts = pdfDateString.replace(/[\/\s]+/g, '-').split('-');
                  if (parts.length === 3) {
                      const p1 = parseInt(parts[0]); const p2 = parseInt(parts[1]); const p3 = parseInt(parts[2]);
                      // Try DD-MM-YYYY or MM-DD-YYYY (assuming YYYY is the long one)
                      if (p3 > 1000) { // Year is likely p3
                          if (p1 <= 31 && p2 <= 12) pdfDate = new Date(p3, p2 - 1, p1); // DD-MM-YYYY
                          else if (p2 <= 31 && p1 <= 12) pdfDate = new Date(p3, p1 - 1, p2); // MM-DD-YYYY
                      } else if (p1 > 1000) { // Year is likely p1
                          if (p2 <= 12 && p3 <= 31) pdfDate = new Date(p1, p2-1, p3); // YYYY-MM-DD
                          else if (p3 <= 12 && p2 <=31) pdfDate = new Date(p1, p3-1, p2); // YYYY-DD-MM (less common)
                      }
                       // Handle YY case if year is short and others are day/month
                      else if (p3 >=0 && p3 <=99 && p1 <=31 && p2 <=12) pdfDate = new Date(p3+2000, p2-1, p1); // DD-MM-YY
                      else if (p3 >=0 && p3 <=99 && p2 <=31 && p1 <=12) pdfDate = new Date(p3+2000, p1-1, p2); // MM-DD-YY

                  } else { // Try to parse with month names if parts aren't 3 numeric
                    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                    let potentialDateStr = pdfDateString;
                    monthNames.forEach((monthName, index) => {
                        potentialDateStr = potentialDateStr.replace(new RegExp(monthName, 'i'), (index + 1).toString());
                    });
                    pdfDate = new Date(potentialDateStr.replace(/\s+/g, '-')); // Replace spaces with hyphens for better parsing
                  }
              }
              
              const requiredDateFromInput = new Date(currentRequiredDateValue); 

              if (isNaN(pdfDate.getTime())) {
                const reason = `Could not parse a valid date from PDF string: "${pdfDateMatch[0]}"`;
                pngData = await convertPDFToPNG(file);
                const id = await db.invalidReceipts.add({ filename: file.name, reason, data: text || "Unable to extract text", pngData, sessionId: currentSession.id });
                setInvalidReceipts(prev => [...prev, { id, filename: file.name, reason, data: text || "Unable to extract text", pngData, sessionId: currentSession.id }]);
                setPdfError(`Failed to process ${file.name}: ${reason}.`);
                return;
              }
              
              pdfDate.setHours(0, 0, 0, 0);
              requiredDateFromInput.setHours(0, 0, 0, 0);

              if (pdfDate < requiredDateFromInput) {
                const reason = `Date in PDF (${pdfDate.toLocaleDateString()}) is older than required date (${requiredDateFromInput.toLocaleDateString()})`;
                pngData = await convertPDFToPNG(file);
                const id = await db.invalidReceipts.add({ filename: file.name, reason, data: text || "Unable to extract text", pngData, sessionId: currentSession.id });
                setInvalidReceipts(prev => [...prev, { id, filename: file.name, reason, data: text || "Unable to extract text", pngData, sessionId: currentSession.id }]);
                setPdfError(`Failed to process ${file.name}: ${reason}. You can manually assign this receipt below.`);
                return; 
              }
            } else {
              const reason = `Required date validation is active, but no date was found in the PDF.`;
              pngData = await convertPDFToPNG(file);
              const id = await db.invalidReceipts.add({ filename: file.name, reason, data: text || "Unable to extract text", pngData, sessionId: currentSession.id });
              setInvalidReceipts(prev => [...prev, { id, filename: file.name, reason, data: text || "Unable to extract text", pngData, sessionId: currentSession.id }]);
              setPdfError(`Failed to process ${file.name}: ${reason}. You can manually assign this receipt below.`);
              return; 
            }
          }
          // --- END: Modified Date Validation Logic ---

          const nameRegex = payers.map(p => new RegExp(`\\b${p.name}\\b`, "i"));
          const amountRegex = /\RM?\d+\.\d{2}\b|\d+\s*RM\b/i;
          const transactionDateRegex = /\b(\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\s+\d{2}:\d{2}:\d{2}|\d{1,2}[/-]\d{1,2}[/-]\d{2,4}(?:\s+\d{2}:\d{2}:\d{2})?|\d{4}[/-]\d{1,2}[/-]\d{1,2}(?:\s+\d{2}:\d{2}:\d{2})?)\b/i;
          
          const extractedText = text.toLowerCase();
          let matchedName = null;
          for (const regex of nameRegex) {
            const match = text.match(regex);
            if (match) {
              matchedName = payers.find(p => regex.test(p.name))?.name;
              break;
            }
          }
          const amountMatch = text.match(amountRegex);
          const extractedAmount = amountMatch ? parseFloat(amountMatch[0].replace(/[^\d.]/g, "")) : null;
          let transactionDate = null;
          const dateMatchForDisplay = text.match(transactionDateRegex); 
          if (dateMatchForDisplay) {
            transactionDate = dateMatchForDisplay[0];
          }
          let matchedPayer = null;
          if (matchedName) {
            matchedPayer = payers.find(p => p.name.toLowerCase() === matchedName.toLowerCase());
          } else {
            const filename = file.name.replace(".pdf", "");
            matchedPayer = BM25.match(filename, payers.filter(p => p.status === "No File Matched" || p.status === "Unpaid")); 
          }
          const existingReceipt = await db.invalidReceipts.where("filename").equals(file.name).and(r => r.sessionId === currentSession.id).first();
          if (existingReceipt) {
            await db.invalidReceipts.delete(existingReceipt.id);
            setInvalidReceipts(prev => prev.filter(r => r.id !== existingReceipt.id));
          }
          const payerWithPDF = payers.find(p => p.pdfFilename === file.name && p.sessionId === currentSession.id);
          if (payerWithPDF) {
            setPdfError(`PDF ${file.name} is already associated with ${payerWithPDF.name}.`);
            return;
          }
          if (!matchedPayer || !extractedAmount) {
            let reason = "No payer matched";
            if (matchedPayer && !extractedAmount) reason = "No amount found in PDF";
            pngData = await convertPDFToPNG(file);
            const id = await db.invalidReceipts.add({ filename: file.name, reason, data: text || "Unable to extract text", pngData, sessionId: currentSession.id });
            setInvalidReceipts(prev => [...prev, { id, filename: file.name, reason, data: text || "Unable to extract text", pngData, sessionId: currentSession.id }]);
            setPdfError(`Failed to process ${file.name}: ${reason}. You can manually assign this receipt below.`);
            return;
          }
          const status = extractedAmount.toFixed(2) === matchedPayer.expectedAmount ? "Paid" : "Incorrect";
          await db.payers.update(matchedPayer.id, { paidAmount: extractedAmount.toFixed(2), transactionDate: transactionDate, status, pdfFilename: file.name });
          setPayers(prev => prev.map(p => p.id === matchedPayer.id ? { ...p, paidAmount: extractedAmount.toFixed(2), transactionDate: transactionDate, status, pdfFilename: file.name } : p));
        } catch (err) {
          console.error(`Error processing ${file.name}:`, err);
          let userFriendlyMessage = "The file may be corrupted or not a valid PDF.";
          if (err.message.includes("Invalid PDF format")) userFriendlyMessage = "The file is not a valid PDF.";
          else if (err.message.includes("doc is not defined")) userFriendlyMessage = "The file could not be read as a PDF.";
          else if (err.message.includes("Invalid PDF structure")) userFriendlyMessage = "The PDF structure is invalid.";
          const reason = `Failed to process: ${userFriendlyMessage}`;
          pngData = await convertPDFToPNG(file);
          const existingReceipt = await db.invalidReceipts.where("filename").equals(file.name).and(r => r.sessionId === currentSession.id).first();
          if (existingReceipt) {
            await db.invalidReceipts.delete(existingReceipt.id);
            setInvalidReceipts(prev => prev.filter(r => r.id !== existingReceipt.id));
          }
          const id = await db.invalidReceipts.add({ filename: file.name, reason, data: text || "Unable to extract text", pngData, sessionId: currentSession.id });
          setInvalidReceipts(prev => [...prev, { id, filename: file.name, reason, data: text || "Unable to extract text", pngData, sessionId: currentSession.id }]);
          setPdfError(`Failed to process ${file.name}: ${userFriendlyMessage}`);
        }
      };

      const handleFileUpload = async (files) => {
        console.log(`[handleFileUpload ENTRY] Validate Checkbox: ${validateReceiptDate}, Required Date: ${requiredReceiptDate}`);
        const pdfFiles = Array.from(files).filter(f => f.type === "application/pdf" || f.name.endsWith(".pdf"));
        if (pdfFiles.length === 0) {
          setPdfError("Please upload files with a .pdf extension");
          return;
        }
        setPdfError("");
        for (const file of pdfFiles) {
          await processPDFLogic(file, validateReceiptDate, requiredReceiptDate);
        }
      };

      const handleDragOver = (e) => { e.preventDefault(); setIsDragging(true); };
      const handleDragLeave = (e) => { e.preventDefault(); setIsDragging(false); };
      const handleDrop = (e) => { e.preventDefault(); setIsDragging(false); handleFileUpload(e.dataTransfer.files); };

      const assignReceipt = async (receiptId, payerId, amount) => {
        if (!payerId || isNaN(amount) || amount <= 0) { setError("Invalid payer or amount"); return; }
        const payer = payers.find(p => p.id === parseInt(payerId));
        const receipt = invalidReceipts.find(r => r.id === receiptId);
        if (!payer || !receipt) { setError("Payer or receipt not found for assignment."); return; }
        const status = parseFloat(amount).toFixed(2) === payer.expectedAmount ? "Paid" : "Incorrect";
        let transactionDate = null;
        const dateRegex = /\b(\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}\s+\d{2}:\d{2}:\d{2}|\d{1,2}[/-]\d{1,2}[/-]\d{2,4}(?:\s+\d{2}:\d{2}:\d{2})?|\d{4}[/-]\d{1,2}[/-]\d{1,2}(?:\s+\d{2}:\d{2}:\d{2})?)\b/i;
        if(receipt.data) {
            const dateMatch = receipt.data.match(dateRegex);
            if (dateMatch) transactionDate = dateMatch[0];
        }
        await db.payers.update(payer.id, { paidAmount: parseFloat(amount).toFixed(2), transactionDate: transactionDate, status, pdfFilename: receipt.filename });
        await db.invalidReceipts.delete(receiptId);
        setPayers(prev => prev.map(p => p.id === payer.id ? { ...p, paidAmount: parseFloat(amount).toFixed(2), transactionDate: transactionDate, status, pdfFilename: receipt.filename } : p));
        setInvalidReceipts(prev => prev.filter(r => r.id !== receiptId));
        setPdfError("");
      };

      const deletePayment = async (id) => {
        await db.payers.update(id, { paidAmount: null, transactionDate: null, status: "No File Matched", pdfFilename: null });
        setPayers(prev => prev.map(p => p.id === id ? { ...p, paidAmount: null, transactionDate: null, status: "No File Matched", pdfFilename: null } : p));
      };

      const deleteInvalidReceipt = async (id) => {
        await db.invalidReceipts.delete(id);
        setInvalidReceipts(prev => prev.filter(r => r.id !== id));
      };

      const exportToCSV = () => {
        const headers = ["Name", "Expected Amount", "Paid Amount", "Transaction Date", "Status", "PDF File"];
        const rows = filteredPayers.map(p => [ p.name, p.expectedAmount, p.paidAmount || "", p.transactionDate || "", p.status, p.pdfFilename || "" ]);
        const csv = [headers, ...rows].map(row => row.join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `payment_tracker_${currentSession ? currentSession.name.replace(/\s+/g, "_") : "unnamed"}.csv`;
        a.click(); URL.revokeObjectURL(url);
      };

      const generatePDF = () => {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({ orientation: orientation, unit: 'mm', format: 'a4' });
        doc.setFontSize(16 * zoom); doc.text("Payment Tracker - Payment Status", 14, 20);
        doc.setFontSize(12 * zoom); doc.text(`Session: ${currentSession ? currentSession.name : "Unnamed"}`, 14, 30);
        doc.text(`Exported on: ${new Date().toLocaleString()}`, 14, 40);
        const headers = ["Name", "Expected Amount", "Paid Amount", "Transaction Date", "Status", "PDF File"];
        const rows = filteredPayers.map(p => [p.name, `RM${p.expectedAmount}`, p.paidAmount ? `RM${p.paidAmount}` : "-", p.transactionDate || "-", p.status, p.pdfFilename || "-"]);
        doc.autoTable({ startY: 50, head: [headers], body: rows, theme: "grid", styles: { fontSize: 8 * zoom, cellPadding: 2 * zoom }, columnStyles: { 0: { cellWidth: 40 * zoom }, 1: { cellWidth: 30 * zoom }, 2: { cellWidth: 30 * zoom }, 3: { cellWidth: 40 * zoom }, 4: { cellWidth: 30 * zoom }, 5: { cellWidth: 40 * zoom } }, margin: { top: 50, left: 14, right: 14 } });
        return doc;
      };

      const exportToPDF = () => {
        const doc = generatePDF();
        const pdfBlob = doc.output('blob');
        const pdfUrl = URL.createObjectURL(pdfBlob);
        setPdfDataUrl(pdfUrl); setIsPrintPreviewOpen(true);
      };

      const handlePrint = () => {
        const doc = generatePDF();
        const sessionName = currentSession ? currentSession.name.replace(/\s+/g, "_") : "unnamed";
        const date = new Date().toISOString().slice(0, 10).replace(/-/g, "");
        doc.save(`payment_status_${sessionName}_${date}.pdf`);
        setIsPrintPreviewOpen(false); if (pdfDataUrl) URL.revokeObjectURL(pdfDataUrl);
      };

      const filteredPayers = payers.filter(p => filter === "All" || p.status === filter)
        .sort((a, b) => {
          if (sortBy === "name-asc") return a.name.localeCompare(b.name);
          if (sortBy === "name-desc") return b.name.localeCompare(a.name);
          if (sortBy === "status-asc") return a.status.localeCompare(b.status);
          if (sortBy === "status-desc") return b.status.localeCompare(a.status);
          return 0;
        });

      if (!isAuthenticated) {
        return (
          <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-gray-100 p-2">
            <div className="bg-white p-3 rounded-lg shadow-lg w-full max-w-xs transform transition-all hover:scale-105">
              <h1 className="text-base font-bold text-gray-800 mb-2 text-center">Payment Tracker</h1>
              {error && <p className="text-red-500 mb-1 text-center text-xs">{error}</p>}
              <form onSubmit={handleLogin}>
                <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} placeholder="Enter password" className="w-full p-1 mb-1 border border-gray-200 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs" required />
                <button type="submit" className="w-full bg-blue-600 text-white p-1 rounded shadow-md hover:bg-blue-700 hover:shadow-lg transition-all duration-300 text-xs">Login</button>
              </form>
            </div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 to-gray-100 p-2">
          <NavBar isAuthenticated={isAuthenticated} currentSession={currentSession} handleLogout={handleLogout} scrollToSection={scrollToSection} openSessionsModal={openSessionsModal} />
          <div className="max-w-5xl mx-auto">
            {error && (<p className="text-red-500 bg-red-50 p-1 rounded mb-2 text-xs animate-pulse">{error}</p>)}
            {isLoading && (<div className="fixed inset-0 bg-gray-800 bg-opacity-50 flex items-center justify-center z-50"><div className="animate-spin rounded-full h-8 w-8 border-t-2 border-blue-500"></div></div>)}
            <div id="dashboard" className="bg-white border border-gray-100 rounded-lg p-3 mb-3 mt-12 shadow-lg">
              {currentSession && (<h3 className="text-base font-bold text-gray-800 text-center bg-blue-50 p-1 rounded mb-3">{currentSession.name}</h3>)}
              <div id="add-payer" className="bg-gray-50 p-3 rounded-lg shadow-sm mb-3">
                <h2 className="text-base font-semibold text-gray-800 mb-2">Add Payer</h2>
                <form onSubmit={addPayer} className="flex flex-col sm:flex-row gap-1 mb-2">
                  <input type="text" value={newPayer.name} onChange={(e) => setNewPayer({ ...newPayer, name: e.target.value })} placeholder="Payer Name" className="p-1 border border-gray-200 rounded flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs" required />
                  <input type="number" value={newPayer.expectedAmount} onChange={(e) => setNewPayer({ ...newPayer, expectedAmount: e.target.value })} placeholder="Expected Amount (RM)" step="0.01" min="0" className="p-1 border border-gray-200 rounded flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs" required />
                  <button type="submit" className="bg-blue-600 text-white px-2 py-1 rounded shadow-md hover:bg-blue-700 hover:shadow-lg transition-all duration-300 text-xs">Add</button>
                </form>
                <div className={`border-2 border-dashed rounded-lg p-3 text-center transition-all duration-300 ${isDraggingCSV ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-gray-50'}`} onDragOver={handleCSVDragOver} onDragLeave={handleCSVDragLeave} onDrop={handleCSVDrop}>
                  <p className="mb-1 text-gray-600 text-xs">Drag and drop a CSV file with payer names and expected amounts, or click to select</p>
                  <input type="file" accept=".csv" onChange={(e) => handleCSVUpload(e.target.files)} className="hidden" id="csvInput" />
                  <label htmlFor="csvInput" className="bg-blue-600 text-white px-2 py-1 rounded shadow-md hover:bg-blue-700 hover:shadow-lg transition-all duration-300 cursor-pointer text-xs">Select CSV File</label>
                </div>
              </div>
              <div id="upload-receipts" className="bg-gray-50 p-3 rounded-lg shadow-sm mb-3">
                <h2 className="text-base font-semibold text-gray-800 mb-2">Upload Receipts</h2>
                {pdfError && <p className="text-red-500 bg-red-50 p-1 rounded mb-1 text-xs">{pdfError}</p>}
                <div className="flex items-center mb-2 space-x-2">
                  <input type="checkbox" id="validateDateCheckbox" checked={validateReceiptDate} onChange={(e) => setValidateReceiptDate(e.target.checked)} className="h-3 w-3 text-blue-600 border-gray-300 rounded focus:ring-blue-500" />
                  <label htmlFor="validateDateCheckbox" className="text-xs text-gray-700">Validate: Receipt date must be on or after</label>
                  <input type="date" value={requiredReceiptDate} onChange={(e) => setRequiredReceiptDate(e.target.value)} disabled={!validateReceiptDate} className={`p-1 border border-gray-200 rounded text-xs focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all ${!validateReceiptDate ? 'bg-gray-100 cursor-not-allowed' : ''}`} />
                </div>
                <div className={`border-2 border-dashed rounded-lg p-3 text-center transition-all duration-300 ${isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-gray-50'}`} onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleDrop}>
                  <p className="mb-1 text-gray-600 text-xs">Drag and drop PDF files here or click to select</p>
                  <input type="file" accept=".pdf" multiple onChange={(e) => handleFileUpload(e.target.files)} className="hidden" id="fileInput" />
                  <label htmlFor="fileInput" className="bg-blue-600 text-white px-2 py-1 rounded shadow-md hover:bg-blue-700 hover:shadow-lg transition-all duration-300 cursor-pointer text-xs">Select Files</label>
                </div>
              </div>
              <div className="bg-gray-50 p-3 rounded-lg shadow-sm mb-3">
                <h2 className="text-base font-semibold text-gray-800 mb-2">Payment Status</h2>
                <div className="flex flex-col sm:flex-row gap-1 mb-2">
                  <select value={filter} onChange={(e) => setFilter(e.target.value)} className="p-1 border border-gray-200 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs">
                    <option value="All">All</option> <option value="Paid">Paid</option> <option value="Unpaid">Unpaid</option> <option value="Incorrect">Incorrect</option> <option value="No File Matched">No File Matched</option>
                  </select>
                  <select value={sortBy} onChange={(e) => setSortBy(e.target.value)} className="p-1 border border-gray-200 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs">
                    <option value="name-asc">Name (A-Z)</option> <option value="name-desc">Name (Z-A)</option> <option value="status-asc">Status (A-Z)</option> <option value="status-desc">Status (Z-A)</option>
                  </select>
                  <button onClick={exportToCSV} className="bg-green-600 text-white px-2 py-1 rounded shadow-md hover:bg-green-700 hover:shadow-lg transition-all duration-300 text-xs">Export to CSV</button>
                  <button onClick={exportToPDF} className="bg-purple-600 text-white px-2 py-1 rounded shadow-md hover:bg-purple-700 hover:shadow-lg transition-all duration-300 text-xs">Export to PDF</button>
                </div>
                <div className="overflow-x-auto">
                  <table className="w-full border-collapse">
                    <thead>
                      <tr className="bg-gray-100">
                        <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Name</th> <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Expected Amount</th> <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Paid Amount</th> <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Transaction Date</th> <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Status</th> <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">PDF File</th> <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Actions</th>
                      </tr>
                    </thead>
                    <tbody>
                      {filteredPayers.map(payer => (
                        <tr key={payer.id} className={payer.status === "Paid" ? "bg-green-50 hover:bg-green-100" : payer.status === "Incorrect" ? "bg-orange-50 hover:bg-orange-100" : "bg-white hover:bg-gray-50"}>
                          <td className="border-b border-gray-200 p-1 text-gray-700 text-xs">{payer.name}</td>
                          <td className="border-b border-gray-200 p-1 text-gray-700 text-xs">RM{payer.expectedAmount}</td>
                          <td className="border-b border-gray-200 p-1 text-gray-700 text-xs">{payer.paidAmount ? `RM${payer.paidAmount}` : "-"}</td>
                          <td className="border-b border-gray-200 p-1 text-gray-700 text-xs">{payer.transactionDate || "-"}</td>
                          <td className="border-b border-gray-200 p-1 text-gray-700 text-xs">{payer.status}</td>
                          <td className="border-b border-gray-200 p-1 text-gray-700 text-xs">{payer.pdfFilename || "-"}</td>
                          <td className="border-b border-gray-200 p-1 flex flex-wrap gap-1">
                            <button onClick={() => { const newName = prompt("Enter new name", payer.name); const newAmount = prompt("Enter new expected amount", payer.expectedAmount); if (newName !== null && newAmount !== null) { editPayer(payer.id, { name: newName, expectedAmount: newAmount }); } }} className="bg-yellow-500 text-white px-1 py-1 rounded shadow-sm hover:bg-yellow-600 hover:shadow-md transition-all duration-300 text-xs">Edit</button>
                            <button onClick={() => deletePayer(payer.id)} className="bg-red-500 text-white px-1 py-1 rounded shadow-sm hover:bg-red-600 hover:shadow-md transition-all duration-300 text-xs">Delete</button>
                            {payer.paidAmount && (<button onClick={() => deletePayment(payer.id)} className="bg-gray-500 text-white px-1 py-1 rounded shadow-sm hover:bg-gray-600 hover:shadow-md transition-all duration-300 text-xs">Clear Payment</button>)}
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
              {invalidReceipts.length > 0 && (
                <div id="invalid-receipts" className="bg-gray-50 p-3 rounded-lg shadow-sm">
                  <h2 className="text-base font-semibold text-gray-800 mb-2">Invalid Receipts</h2>
                  <div className="overflow-x-auto">
                    <table className="w-full border-collapse">
                      <thead>
                        <tr className="bg-gray-100">
                          <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Filename</th> <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Preview</th> <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Reason</th> <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Assign</th> <th className="border-b border-gray-200 p-1 text-left text-gray-700 font-semibold text-xs">Actions</th>
                        </tr>
                      </thead>
                      <tbody>
                        {invalidReceipts.map(receipt => (
                          <tr key={receipt.id} className="hover:bg-gray-50">
                            <td className="border-b border-gray-200 p-1 text-gray-700 text-xs">{receipt.filename}</td>
                            <td className="border-b border-gray-200 p-1 text-gray-700">{receipt.pngData ? (<img src={receipt.pngData} alt="PDF Preview" className="max-w-[80px] h-auto rounded shadow-sm cursor-pointer" onClick={() => openModal(receipt.pngData)} />) : (<span className="text-gray-500 text-xs">No preview</span>)}</td>
                            <td className="border-b border-gray-200 p-1 text-gray-700 text-xs">{receipt.reason}</td>
                            <td className="border-b border-gray-200 p-1 flex gap-1">
                              <select className="p-1 border border-gray-200 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all text-xs" defaultValue="" onChange={(e) => { const selPayerId = e.target.value; if (selPayerId) { const amt = prompt(`Enter amount for ${payers.find(p=>p.id===parseInt(selPayerId))?.name || 'payer'}`); if (amt !== null) { assignReceipt(receipt.id, selPayerId, amt); } } e.target.value = ""; }}>
                                <option value="">Select Payer</option>
                                {payers.filter(p => !p.pdfFilename).map(p => (<option key={p.id} value={p.id}>{p.name}</option>))}
                              </select>
                            </td>
                            <td className="border-b border-gray-200 p-1"><button onClick={() => deleteInvalidReceipt(receipt.id)} className="bg-red-500 text-white px-1 py-1 rounded shadow-sm hover:bg-red-600 hover:shadow-md transition-all duration-300 text-xs">Delete</button></td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}
            </div>
            <ImageModal isOpen={isModalOpen} onClose={closeModal} imageSrc={selectedImage} />
            <SessionsModal isOpen={isSessionsModalOpen} onClose={closeSessionsModal} sessions={sessions} deletedSessions={deletedSessions} currentSession={currentSession} setSessions={setSessions} setDeletedSessions={setDeletedSessions} setCurrentSession={setCurrentSession} setPayers={setPayers} setInvalidReceipts={setInvalidReceipts} setError={setError} setIsLoading={setIsLoading} newSessionName={newSessionName} setNewSessionName={setNewSessionName} openSession={openSession} createNewSession={createNewSession} deleteSession={deleteSession} restoreSession={restoreSession} permanentlyDeleteSession={permanentlyDeleteSession} clearTrashBin={clearTrashBin} />
            <PrintPreviewModal isOpen={isPrintPreviewOpen} onClose={() => { setIsPrintPreviewOpen(false); if (pdfDataUrl) URL.revokeObjectURL(pdfDataUrl); }} onPrint={handlePrint} pdfDataUrl={pdfDataUrl} setOrientation={setOrientation} setZoom={setZoom} />
          </div>
        </div>
      );
    }
    ReactDOM.render(<App />, document.getElementById("root"));
  </script>
</body>
</html>
